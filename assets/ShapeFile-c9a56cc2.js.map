{"version":3,"file":"ShapeFile-c9a56cc2.js","sources":["../../node_modules/reproject/index.js","../../node_modules/truncate-utf8-bytes/lib/truncate.js","../../node_modules/utf8-byte-length/browser.js","../../node_modules/truncate-utf8-bytes/browser.js","../../node_modules/sanitize-filename/index.js","../../node_modules/@deck.gl/layers/src/geojson-layer/sub-layer-map.ts","../../src/layers/GeojsonOffsetLayer.ts","../../src/js/screenshots.ts","../../src/plugins/shape-file/GeojsonLayer.tsx","../../src/components/BackgroundMapOnTop.vue","../../src/plugins/shape-file/ModalIdColumnPicker.vue","../../src/plugins/shape-file/ShapeFile.vue"],"sourcesContent":["'use strict';\n\nvar proj4 = require('proj4').hasOwnProperty('default') ? require('proj4').default : require('proj4');\n// Checks if `list` looks like a `[x, y]`.\nfunction isXY(list) {\n  return list.length >= 2 &&\n    typeof list[0] === 'number' &&\n    typeof list[1] === 'number';\n}\n\nfunction traverseCoords(coordinates, callback) {\n  if (isXY(coordinates)) return callback(coordinates);\n  return coordinates.map(function(coord){return traverseCoords(coord, callback);});\n}\n\n// Simplistic shallow clone that will work for a normal GeoJSON object.\nfunction clone(obj) {\n  if (null == obj || 'object' !== typeof obj) return obj;\n  var copy = obj.constructor();\n  for (var attr in obj) {\n    if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];\n  }\n  return copy;\n}\n\nfunction traverseGeoJson(geometryCb, nodeCb, geojson) {\n  if (geojson == null) return geojson;\n\n  var r = clone(geojson);\n  var self = traverseGeoJson.bind(this, geometryCb, nodeCb);\n\n  switch (geojson.type) {\n  case 'Feature':\n    r.geometry = self(geojson.geometry);\n    break;\n  case 'FeatureCollection':\n    r.features = r.features.map(self);\n    break;\n  case 'GeometryCollection':\n    r.geometries = r.geometries.map(self);\n    break;\n  default:\n    geometryCb(r);\n    break;\n  }\n\n  if (nodeCb) nodeCb(r);\n\n  return r;\n}\n\nfunction detectCrs(geojson, projs) {\n  var crsInfo = geojson.crs,\n      crs;\n\n  if (crsInfo === undefined) {\n    throw new Error('Unable to detect CRS, GeoJSON has no \"crs\" property.');\n  }\n\n  if (crsInfo.type === 'name') {\n    crs = projs[crsInfo.properties.name];\n  } else if (crsInfo.type === 'EPSG') {\n    crs = projs['EPSG:' + crsInfo.properties.code];\n  }\n\n  if (!crs) {\n    throw new Error('CRS defined in crs section could not be identified: ' + JSON.stringify(crsInfo));\n  }\n\n  return crs;\n}\n\nfunction determineCrs(crs, projs) {\n  if (typeof crs === 'string' || crs instanceof String) {\n    return projs[crs] || proj4.Proj(crs);\n  }\n\n  return crs;\n}\n\nfunction calcBbox(geojson) {\n  var min = [Number.MAX_VALUE, Number.MAX_VALUE],\n      max = [-Number.MAX_VALUE, -Number.MAX_VALUE];\n  traverseGeoJson(function(_gj) {\n    traverseCoords(_gj.coordinates, function(xy) {\n      min[0] = Math.min(min[0], xy[0]);\n      min[1] = Math.min(min[1], xy[1]);\n      max[0] = Math.max(max[0], xy[0]);\n      max[1] = Math.max(max[1], xy[1]);\n    });\n  }, null, geojson);\n  return [min[0], min[1], max[0], max[1]];\n}\n\nfunction reproject(geojson, from, to, projs) {\n  projs = projs || {};\n  if (!from) {\n    from = detectCrs(geojson, projs);\n  } else {\n    from = determineCrs(from, projs);\n  }\n\n  to = determineCrs(to, projs);\n  \n  var transformFunc = proj4(from, to).forward.bind(transformFunc);\n\n  function transform(coords) {\n    var transformed = transformFunc(coords);\n    if (coords.length === 3 && coords[2] !== undefined && transformed[2] === undefined) {\n      // If the projection doesn't explicitly handle Z coordinate, retain the old one.\n      transformed[2] = coords[2];\n    }\n    return transformed;\n  }\n\n  var transformGeometryCoords = function(gj) {\n    // No easy way to put correct CRS info into the GeoJSON,\n    // and definitely wrong to keep the old, so delete it.\n    if (gj.crs) {\n      delete gj.crs;\n    }\n    gj.coordinates = traverseCoords(gj.coordinates, transform);\n  }\n\n  var transformBbox = function(gj) {\n    if (gj.bbox) {\n      gj.bbox = calcBbox(gj);\n    }\n  }\n\n  return traverseGeoJson(transformGeometryCoords, transformBbox, geojson);\n}\n\nmodule.exports = {\n  detectCrs: detectCrs,\n\n  reproject: reproject,\n\n  reverse: function(geojson) {\n    return traverseGeoJson(function(gj) {\n      gj.coordinates = traverseCoords(gj.coordinates, function(xy) {\n        return [ xy[1], xy[0] ];\n      });\n    }, null, geojson);\n  },\n\n  toWgs84: function(geojson, from, projs) {\n    return reproject(geojson, from, proj4.WGS84, projs);\n  }\n};\n","'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function truncate(getLength, string, byteLength) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var curByteLength = 0;\n  var codePoint;\n  var segment;\n\n  for (var i = 0; i < charLength; i += 1) {\n    codePoint = string.charCodeAt(i);\n    segment = string[i];\n\n    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {\n      i += 1;\n      segment += string[i];\n    }\n\n    curByteLength += getLength(segment);\n\n    if (curByteLength === byteLength) {\n      return string.slice(0, i + 1);\n    }\n    else if (curByteLength > byteLength) {\n      return string.slice(0, i - segment.length + 1);\n    }\n  }\n\n  return string;\n};\n\n","'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function getByteLength(string) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var byteLength = 0;\n  var codePoint = null;\n  var prevCodePoint = null;\n  for (var i = 0; i < charLength; i++) {\n    codePoint = string.charCodeAt(i);\n    // handle 4-byte non-BMP chars\n    // low surrogate\n    if (isLowSurrogate(codePoint)) {\n      // when parsing previous hi-surrogate, 3 is added to byteLength\n      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {\n        byteLength += 1;\n      }\n      else {\n        byteLength += 3;\n      }\n    }\n    else if (codePoint <= 0x7f ) {\n      byteLength += 1;\n    }\n    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {\n      byteLength += 2;\n    }\n    else if (codePoint >= 0x800 && codePoint <= 0xffff) {\n      byteLength += 3;\n    }\n    prevCodePoint = codePoint;\n  }\n\n  return byteLength;\n};\n","'use strict';\n\nvar truncate = require(\"./lib/truncate\");\nvar getLength = require(\"utf8-byte-length/browser\");\nmodule.exports = truncate.bind(null, getLength);\n","/*jshint node:true*/\n'use strict';\n\n/**\n * Replaces characters in strings that are illegal/unsafe for filenames.\n * Unsafe characters are either removed or replaced by a substitute set\n * in the optional `options` object.\n *\n * Illegal Characters on Various Operating Systems\n * / ? < > \\ : * | \"\n * https://kb.acronis.com/content/39790\n *\n * Unicode Control codes\n * C0 0x00-0x1f & C1 (0x80-0x9f)\n * http://en.wikipedia.org/wiki/C0_and_C1_control_codes\n *\n * Reserved filenames on Unix-based systems (\".\", \"..\")\n * Reserved filenames in Windows (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\",\n * \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\",\n * \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", and\n * \"LPT9\") case-insesitively and with or without filename extensions.\n *\n * Capped at 255 characters in length.\n * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs\n *\n * @param  {String} input   Original filename\n * @param  {Object} options {replacement: String | Function }\n * @return {String}         Sanitized filename\n */\n\nvar truncate = require(\"truncate-utf8-bytes\");\n\nvar illegalRe = /[\\/\\?<>\\\\:\\*\\|\"]/g;\nvar controlRe = /[\\x00-\\x1f\\x80-\\x9f]/g;\nvar reservedRe = /^\\.+$/;\nvar windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\\..*)?$/i;\nvar windowsTrailingRe = /[\\. ]+$/;\n\nfunction sanitize(input, replacement) {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be string');\n  }\n  var sanitized = input\n    .replace(illegalRe, replacement)\n    .replace(controlRe, replacement)\n    .replace(reservedRe, replacement)\n    .replace(windowsReservedRe, replacement)\n    .replace(windowsTrailingRe, replacement);\n  return truncate(sanitized, 255);\n}\n\nmodule.exports = function (input, options) {\n  var replacement = (options && options.replacement) || '';\n  var output = sanitize(input, replacement);\n  if (replacement === '') {\n    return output;\n  }\n  return sanitize(output, '');\n};\n","import {CompositeLayer, Layer} from '@deck.gl/core';\n\nimport IconLayer from '../icon-layer/icon-layer';\nimport ScatterplotLayer from '../scatterplot-layer/scatterplot-layer';\nimport TextLayer from '../text-layer/text-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\n\nexport const POINT_LAYER = {\n  circle: {\n    type: ScatterplotLayer,\n    props: {\n      filled: 'filled',\n      stroked: 'stroked',\n\n      lineWidthMaxPixels: 'lineWidthMaxPixels',\n      lineWidthMinPixels: 'lineWidthMinPixels',\n      lineWidthScale: 'lineWidthScale',\n      lineWidthUnits: 'lineWidthUnits',\n      pointRadiusMaxPixels: 'radiusMaxPixels',\n      pointRadiusMinPixels: 'radiusMinPixels',\n      pointRadiusScale: 'radiusScale',\n      pointRadiusUnits: 'radiusUnits',\n      pointAntialiasing: 'antialiasing',\n      pointBillboard: 'billboard',\n\n      getFillColor: 'getFillColor',\n      getLineColor: 'getLineColor',\n      getLineWidth: 'getLineWidth',\n      getPointRadius: 'getRadius'\n    }\n  },\n  icon: {\n    type: IconLayer,\n    props: {\n      iconAtlas: 'iconAtlas',\n      iconMapping: 'iconMapping',\n\n      iconSizeMaxPixels: 'sizeMaxPixels',\n      iconSizeMinPixels: 'sizeMinPixels',\n      iconSizeScale: 'sizeScale',\n      iconSizeUnits: 'sizeUnits',\n      iconAlphaCutoff: 'alphaCutoff',\n      iconBillboard: 'billboard',\n\n      getIcon: 'getIcon',\n      getIconAngle: 'getAngle',\n      getIconColor: 'getColor',\n      getIconPixelOffset: 'getPixelOffset',\n      getIconSize: 'getSize'\n    }\n  },\n  text: {\n    type: TextLayer,\n    props: {\n      textSizeMaxPixels: 'sizeMaxPixels',\n      textSizeMinPixels: 'sizeMinPixels',\n      textSizeScale: 'sizeScale',\n      textSizeUnits: 'sizeUnits',\n\n      textBackground: 'background',\n      textBackgroundPadding: 'backgroundPadding',\n      textFontFamily: 'fontFamily',\n      textFontWeight: 'fontWeight',\n      textLineHeight: 'lineHeight',\n      textMaxWidth: 'maxWidth',\n      textOutlineColor: 'outlineColor',\n      textOutlineWidth: 'outlineWidth',\n      textWordBreak: 'wordBreak',\n      textCharacterSet: 'characterSet',\n      textBillboard: 'billboard',\n      textFontSettings: 'fontSettings',\n\n      getText: 'getText',\n      getTextAngle: 'getAngle',\n      getTextColor: 'getColor',\n      getTextPixelOffset: 'getPixelOffset',\n      getTextSize: 'getSize',\n      getTextAnchor: 'getTextAnchor',\n      getTextAlignmentBaseline: 'getAlignmentBaseline',\n      getTextBackgroundColor: 'getBackgroundColor',\n      getTextBorderColor: 'getBorderColor',\n      getTextBorderWidth: 'getBorderWidth'\n    }\n  }\n};\n\nexport const LINE_LAYER = {\n  type: PathLayer,\n  props: {\n    lineWidthUnits: 'widthUnits',\n    lineWidthScale: 'widthScale',\n    lineWidthMinPixels: 'widthMinPixels',\n    lineWidthMaxPixels: 'widthMaxPixels',\n    lineJointRounded: 'jointRounded',\n    lineCapRounded: 'capRounded',\n    lineMiterLimit: 'miterLimit',\n    lineBillboard: 'billboard',\n\n    getLineColor: 'getColor',\n    getLineWidth: 'getWidth'\n  }\n};\n\nexport const POLYGON_LAYER = {\n  type: SolidPolygonLayer,\n  props: {\n    extruded: 'extruded',\n    filled: 'filled',\n    wireframe: 'wireframe',\n    elevationScale: 'elevationScale',\n    material: 'material',\n\n    getElevation: 'getElevation',\n    getFillColor: 'getFillColor',\n    getLineColor: 'getLineColor'\n  }\n};\n\nexport function getDefaultProps({\n  type,\n  props\n}: {\n  type: typeof Layer;\n  props: Record<string, string>;\n}): Record<string, any> {\n  const result = {};\n  for (const key in props) {\n    result[key] = type.defaultProps[props[key]];\n  }\n  return result;\n}\n\nexport function forwardProps(\n  layer: CompositeLayer,\n  mapping: Record<string, string>\n): Record<string, any> {\n  const {transitions, updateTriggers} = layer.props;\n  const result: Record<string, any> = {\n    updateTriggers: {},\n    transitions: transitions && {\n      getPosition: transitions.geometry\n    }\n  };\n\n  for (const sourceKey in mapping) {\n    const targetKey = mapping[sourceKey];\n    let value = layer.props[sourceKey];\n    if (sourceKey.startsWith('get')) {\n      // isAccessor\n      value = (layer as any).getSubLayerAccessor(value);\n      result.updateTriggers[targetKey] = updateTriggers[sourceKey];\n      if (transitions) {\n        result.transitions[targetKey] = transitions[sourceKey];\n      }\n    }\n    result[targetKey] = value;\n  }\n  return result;\n}\n","import { GeoJsonLayer } from '@deck.gl/layers'\nimport PathOffsetLayer from '@/layers/PathOffsetLayer'\nimport { forwardProps } from '@deck.gl/layers/src/geojson-layer/sub-layer-map'\n\nconst OFFSET_TYPE = {\n  NONE: 0,\n  LEFT: 1,\n  RIGHT: 2,\n}\n\nexport const LINE_LAYER = {\n  type: PathOffsetLayer,\n  props: {\n    lineWidthUnits: 'widthUnits',\n    lineWidthScale: 'widthScale',\n    lineWidthMinPixels: 'widthMinPixels',\n    lineWidthMaxPixels: 'widthMaxPixels',\n    lineJointRounded: 'jointRounded',\n    lineCapRounded: 'capRounded',\n    lineMiterLimit: 'miterLimit',\n    lineBillboard: 'billboard',\n    getLineColor: 'getColor',\n    getLineWidth: 'getWidth',\n  },\n}\n\nexport default class GeojsonOffsetLayer extends GeoJsonLayer {\n  constructor(props: any) {\n    super(props)\n  }\n\n  // this is copied directly from @deck.gl/layers/geojson-layer\n  _renderLineLayers() {\n    const { extruded, stroked } = this.props\n    const { layerProps } = this.state\n    const polygonStrokeLayerId = 'polygons-stroke'\n    const lineStringsLayerId = 'linestrings'\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type)\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type)\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props)\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers,\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers,\n            }),\n            layerProps.lines\n          ),\n      ]\n    }\n    return null\n  }\n\n  getShaders() {\n    return {\n      ...super.getShaders(),\n      inject: {\n        'vs:#decl': `\n            attribute float instanceOffset;\n            varying float offset;\n            `,\n        'vs:#main-start': `\n            offset = instanceOffset;\n            `,\n        'fs:#decl': `\n            varying float offset;\n            `,\n        'fs:#main-start': `\n            if (offset == 1.0 && vPathPosition.x < 0.0) {\n                discard;\n            }\n            if (offset == 2.0 && vPathPosition.x > 0.0) {\n                discard;\n            }\n            if (offset == 0.0 && abs(vPathPosition.x) > 0.5) {\n                discard;\n            }\n        `,\n      },\n    }\n  }\n}\n\nGeojsonOffsetLayer.layerName = 'GeojsonOffsetLayer'\nGeojsonOffsetLayer.defaultProps = {\n  getOffset: { type: 'accessor', value: OFFSET_TYPE.RIGHT },\n}\n\n// /** DeckGL **/\n// new deck.DeckGL({\n//   container: 'container',\n//   mapboxApiAccessToken: '',\n//   longitude: -122.408,\n//   latitude: 37.785,\n//   zoom: 16,\n//   pitch: 0,\n//   layers: [\n//     new deck.PathLayer({\n//       data:\n//         'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/website/bart-lines.json',\n//       getPath: d => d.path,\n//       getColor: [0, 0, 0],\n//       getWidth: 50,\n//     }),\n//     new MyPathLayer({\n//       data:\n//         'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/website/bart-lines.json',\n//       getPath: d => d.path,\n//       getColor: [255, 0, 0],\n//       getOffset: (d, { index }) => index % 3,\n//       getWidth: 50,\n//       pickable: true,\n//       autoHighlight: true,\n//     }),\n//   ],\n// })\n","// screenshot helper functions\n// found most of this at:\n// (1) https://github.com/visgl/deck.gl/issues/4436\n// (2) https://stackoverflow.com/questions/32096540/merge-two-datauris-to-create-a-single-image\n\nimport { DeckGLLayer } from '@flowmap.gl/core'\n\nexport async function savePNG(layer: DeckGLLayer, backgroundCanvas: HTMLCanvasElement) {\n  const deckLayerImage = layer.context.deck.canvas.toDataURL('image/png')\n  const backgroundImage = backgroundCanvas?.toDataURL('image/png')\n\n  const layerData = []\n  if (backgroundImage) layerData.push(backgroundImage)\n  layerData.push(deckLayerImage)\n\n  // convert deck+map to image URL, with added watermark\n  const mergedImage = await mergeImageURIs({\n    width: layer.context.deck.canvas.width,\n    height: layer.context.deck.canvas.height,\n    imageDataURLs: layerData,\n  })\n\n  var element = document.createElement('a')\n  element.setAttribute('href', mergedImage)\n  element.setAttribute('download', 'screenshot.png')\n  element.style.display = 'none'\n\n  document.body.appendChild(element)\n  element.click()\n  document.body.removeChild(element)\n}\n\n// copypasta from\n// https://stackoverflow.com/questions/32096540/merge-two-datauris-to-create-a-single-image\nfunction mergeImageURIs(props: { width: number; height: number; imageDataURLs: string[] }) {\n  return new Promise<any>((resolve, reject) => {\n    var canvas = document.createElement('canvas')\n    canvas.width = props.width\n    canvas.height = props.height\n\n    Promise.all(props.imageDataURLs.map(dataURL => add2canvas(canvas, dataURL))).then(() => {\n      // add watermark\n      const ctx = canvas.getContext('2d') as any\n      const boxLeft = canvas.width - 152\n      const boxTop = canvas.height - 8\n      ctx.beginPath()\n      ctx.rect(boxLeft - 4, boxTop - 14, 158, 22)\n      ctx.fillStyle = '#ffffff44'\n      ctx.fill()\n      ctx.font = '11px Arial'\n      ctx.fillStyle = '#888'\n      ctx.fillText('© Mapbox  © OpenStreetMap', boxLeft, boxTop)\n\n      // return final dataURL with fully-built image\n      resolve(canvas.toDataURL('image/png'))\n    })\n  })\n}\n\nfunction add2canvas(canvas: any, dataURL: string) {\n  return new Promise((resolve, reject) => {\n    if (!canvas) reject()\n    if (!dataURL) reject()\n\n    var image = new Image()\n\n    image.onload = function () {\n      canvas.getContext('2d').drawImage(this, 0, 0)\n      resolve(true)\n    }\n    image.src = dataURL\n  })\n}\n\nexport default { savePNG }\n","import React, { useState, useMemo, useEffect, useRef } from 'react'\nimport DeckGL from '@deck.gl/react'\nimport { DataFilterExtension } from '@deck.gl/extensions'\n\nimport { StaticMap, MapRef } from 'react-map-gl'\nimport { rgb } from 'd3-color'\n\nimport { DataTable, MAPBOX_TOKEN, REACT_VIEW_HANDLES } from '@/Globals'\n\nimport globalStore from '@/store'\nimport { OFFSET_DIRECTION } from '@/layers/LineOffsetLayer'\nimport GeojsonOffsetLayer from '@/layers/GeojsonOffsetLayer'\n\nimport screenshots from '@/js/screenshots'\n\ninterface DeckObject {\n  index: number\n  target: number[]\n  data: any\n}\n\nexport default function Component({\n  viewId = 0,\n  fillColors = '#59a14f' as string | Uint8Array,\n  lineColors = '#4e79a7' as string | Uint8Array,\n  lineWidths = 0 as number | Float32Array,\n  fillHeights = 0 as number | Float32Array,\n  calculatedValues = null as null | Float32Array,\n  calculatedValueLabel = '',\n  normalizedValues = null as null | Float32Array,\n  opacity = 1,\n  pointRadii = 4 as number | Float32Array,\n  screenshot = 0,\n  featureDataTable = {} as DataTable,\n  featureFilter = new Float32Array(0),\n  tooltip = [] as string[],\n  cbTooltip = {} as any,\n}) {\n  const PRECISION = 4\n\n  // const features = globalStore.state.globalCache[viewId] as any[]\n  const [features, setFeatures] = useState([] as any[])\n\n  const [viewState, setViewState] = useState(globalStore.state.viewState)\n  const [screenshotCount, setScreenshot] = useState(screenshot)\n\n  const _mapRef = useRef<MapRef>() as any\n  // release _mapRef on unmount to avoid memory leak\n  // TODO: WAIT! Releasing _mapRef breaks screenshot functionality.\n  // useEffect(() => {\n  //   if (screenshot <= screenshotCount) _mapRef.current = false\n  // })\n\n  // MAP VIEW -------------------------------------------------------------------------\n  REACT_VIEW_HANDLES[viewId] = () => {\n    setViewState(globalStore.state.viewState)\n  }\n\n  // Feature setter hack:\n  // Using the array itself causes an enormous memory leak. I am not sure why\n  // Vue/React/Deck.gl are not managing this array correctly. Surely the problem\n  // is in our code, not theirs? But I spent days trying to find it.\n  // Anyway, making this deep copy of the feature array seems to solve it.\n  REACT_VIEW_HANDLES[1000 + viewId] = (features: any[]) => {\n    const fullCopy = features.map(feature => {\n      const f = {\n        type: '' + feature.type,\n        geometry: JSON.parse(JSON.stringify(feature.geometry)),\n        properties: JSON.parse(JSON.stringify(feature?.properties || {})),\n      } as any\n      if ('id' in feature) f.id = '' + feature.id\n      return f\n    })\n    setFeatures(fullCopy)\n  }\n\n  // SCREENSHOT -----------------------------------------------------------------------\n  let isTakingScreenshot = screenshot > screenshotCount\n\n  // FILL COLORS ----------------------------------------------------------------------\n  let cbFillColor // can be callback OR a plain string in simple mode\n  if (typeof fillColors == 'string') {\n    // simple color mode\n    const color = rgb(fillColors)\n    cbFillColor = [color.r, color.g, color.b]\n  } else {\n    // array of colors\n    cbFillColor = (feature: any, o: DeckObject) => {\n      return [\n        fillColors[o.index * 3 + 0], // r\n        fillColors[o.index * 3 + 1], // g\n        fillColors[o.index * 3 + 2], // b\n        255, // no opacity, for now\n      ]\n    }\n  }\n\n  // LINE COLORS ----------------------------------------------------------------------\n  const isStroked = !!lineColors\n\n  let cbLineColor // can be callback OR a plain string in simple mode\n  if (typeof lineColors == 'string') {\n    // simple color mode\n    const color = rgb(lineColors)\n    cbLineColor = [color.r, color.g, color.b]\n    if (!isStroked) cbLineColor.push(0) // totally transparent\n  } else {\n    // array of colors\n    cbLineColor = (_: any, o: DeckObject) => {\n      if (features[o.index].properties._hide) return [0, 0, 0, 0]\n\n      return [\n        lineColors[o.index * 3 + 0], // r\n        lineColors[o.index * 3 + 1], // g\n        lineColors[o.index * 3 + 2], // b\n        255, // no opacity, for now\n      ]\n    }\n  }\n\n  // LINE WIDTHS ----------------------------------------------------------------------\n  let cbLineWidth // can be callback OR a plain string in simple mode\n  if (typeof lineWidths == 'number') {\n    // simple width mode\n    cbLineWidth = lineWidths\n  } else {\n    // array of widths\n    cbLineWidth = (_: any, o: DeckObject) => {\n      return lineWidths[o.index]\n    }\n  }\n\n  // CIRCLE RADIISESS ---------------------------------------------------------------\n  let cbPointRadius // can be callback OR a plain string in simple mode\n  if (typeof pointRadii == 'number') {\n    // simple radius mode\n    cbPointRadius = pointRadii\n  } else {\n    cbPointRadius = (_: any, o: DeckObject) => {\n      return pointRadii[o.index]\n    }\n  }\n\n  // FILL HEIGHTS -----------------------------------------------------------------\n  let cbFillHeight // can be callback OR a plain string in simple mode\n  if (typeof fillHeights == 'number') {\n    // simple mode\n    cbFillHeight = fillHeights\n  } else {\n    // array function\n    cbFillHeight = (_: any, o: DeckObject) => {\n      return fillHeights[o.index]\n    }\n  }\n\n  function handleViewState(view: any) {\n    if (!view.latitude) return\n    view.center = [view.longitude, view.latitude]\n    setViewState(view)\n    globalStore.commit('setMapCamera', view)\n  }\n\n  // CLICK  ---------------------------------------------------------------------\n  function handleClick() {\n    console.log('click!')\n  }\n\n  // this will only round a number if it is a plain old regular number with\n  // a fractional part to the right of the decimal point.\n  function truncateFractionalPart({ value, precision }: { value: any; precision: number }) {\n    if (typeof value !== 'number') return value\n\n    let printValue = '' + value\n    if (printValue.includes('.') && printValue.indexOf('.') === printValue.lastIndexOf('.')) {\n      if (/\\d$/.test(printValue))\n        return printValue.substring(0, 1 + PRECISION + printValue.lastIndexOf('.')) // precise(value, precision)\n    }\n    return value\n  }\n\n  // TOOLTIP ------------------------------------------------------------------\n  function getTooltip({ object, index }: { object: any; index: number }) {\n    // tooltip will show values for color settings and for width settings.\n    // if there is base data, it will also show values and diff vs. base for both color and width.\n\n    if (!cbTooltip) return null\n\n    if (object === null || !features[index]?.properties) {\n      cbTooltip(null)\n      return null\n    }\n\n    const propList = []\n\n    // normalized value first\n    if (normalizedValues) {\n      const label = calculatedValueLabel ?? 'Normalized Value'\n      let value = truncateFractionalPart({ value: normalizedValues[index], precision: PRECISION })\n\n      propList.push(\n        `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${label}</td><td><b>${value}</b></td></tr>`\n      )\n    }\n\n    // calculated value\n    if (calculatedValues) {\n      let cLabel = calculatedValueLabel ?? 'Value'\n\n      const label = normalizedValues ? cLabel.substring(0, cLabel.lastIndexOf('/')) : cLabel\n      let value = truncateFractionalPart({ value: calculatedValues[index], precision: PRECISION })\n\n      if (calculatedValueLabel.startsWith('%')) value = `${value} %`\n\n      propList.push(\n        `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${label}</td><td><b>${value}</b></td></tr>\n         <tr><td>&nbsp;</td></tr>`\n      )\n    }\n\n    // --- dataset tooltip lines ---\n    let datasetProps = ''\n    const featureTips = Object.entries(features[index].properties)\n\n    for (const [tipKey, tipValue] of featureTips) {\n      if (tipValue === null) continue\n\n      // Truncate fractional digits IF it is a simple number that has a fraction\n      let value = truncateFractionalPart({ value: tipValue, precision: 4 })\n      datasetProps += `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${tipKey}</td><td><b>${value}</b></td></tr>`\n    }\n\n    if (datasetProps) propList.push(datasetProps)\n\n    // --- boundary feature tooltip lines ---\n    let columns = Object.keys(featureDataTable)\n    if (tooltip && tooltip.length) {\n      columns = tooltip.map(tip => {\n        return tip.substring(tip.indexOf('.') + 1)\n      })\n    }\n\n    let featureProps = ''\n    columns.forEach(column => {\n      if (featureDataTable[column]) {\n        let value = featureDataTable[column].values[index]\n        if (value == null) return\n        if (typeof value == 'number') value = truncateFractionalPart({ value, precision: 4 })\n\n        featureProps += `<tr><td style=\"text-align: right; padding-right: 0.5rem;\">${column}</td><td><b>${value}</b></td></tr>`\n      }\n    })\n    if (featureProps) propList.push(featureProps)\n\n    // nothing to show? no tooltip\n    if (!propList.length) {\n      cbTooltip(null)\n      return\n    }\n\n    let finalHTML = propList.join('')\n    const html = `<table>${finalHTML}</table>`\n\n    cbTooltip(html)\n\n    return null\n  }\n\n  const layer = new GeojsonOffsetLayer({\n    id: 'geoJsonOffsetLayer',\n    data: features,\n    // function callbacks: --------------\n    getLineWidth: cbLineWidth,\n    getLineColor: cbLineColor,\n    getFillColor: cbFillColor,\n    getPointRadius: cbPointRadius,\n    getElevation: cbFillHeight,\n    // settings: ------------------------\n    autoHighlight: true,\n    extruded: !!fillHeights,\n    highlightColor: [255, 0, 224],\n    // lineJointRounded: true,\n    lineWidthUnits: 'pixels',\n    lineWidthScale: 1,\n    lineWidthMinPixels: typeof lineWidths === 'number' ? 0 : 1,\n    lineWidthMaxPixels: 50,\n    getOffset: OFFSET_DIRECTION.RIGHT,\n    opacity: fillHeights ? 1.0 : 0.8, // 3D must be opaque\n    pickable: true,\n    pointRadiusUnits: 'pixels',\n    pointRadiusMinPixels: 2,\n    // pointRadiusMaxPixels: 50,\n    stroked: isStroked,\n    useDevicePixels: isTakingScreenshot,\n    fp64: false,\n    // material: false,\n    updateTriggers: {\n      getFillColor: fillColors,\n      getLineColor: lineColors,\n      getLineWidth: lineWidths,\n      getPointRadius: pointRadii,\n      getElevation: fillHeights,\n      getFilterValue: featureFilter,\n    },\n    transitions: {\n      getFillColor: 300,\n      getLineColor: 300,\n      getLineWidth: 300,\n      getPointRadius: 300,\n    },\n    parameters: {\n      depthTest: !!fillHeights,\n      fp64: false,\n    },\n    glOptions: {\n      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n      preserveDrawingBuffer: true,\n      fp64: false,\n    },\n    // filter shapes\n    extensions: [new DataFilterExtension({ filterSize: 1 })],\n    filterRange: [0, 1], // set filter to -1 to filter element out\n    getFilterValue: (_: any, o: DeckObject) => {\n      return featureFilter[o.index]\n    },\n  }) as any\n\n  const deckInstance = (\n    /*\n    //@ts-ignore */\n    <DeckGL\n      layers={[layer]}\n      viewState={viewState}\n      controller={true}\n      pickingRadius={4}\n      getTooltip={getTooltip}\n      onClick={handleClick}\n      onViewStateChange={(e: any) => handleViewState(e.viewState)}\n      getCursor={({ isDragging, isHovering }: any) =>\n        isDragging ? 'grabbing' : isHovering ? 'pointer' : 'grab'\n      }\n      onAfterRender={async () => {\n        if (screenshot > screenshotCount) {\n          await screenshots.savePNG(\n            deckInstance.props.layers[0],\n            _mapRef?.current?.getMap()._canvas\n          )\n          setScreenshot(screenshot) // update scrnshot count so we don't take 1000 screenshots by mistake :-/\n        }\n      }}\n    >\n      {\n        /*\n        // @ts-ignore */\n        <StaticMap mapStyle={globalStore.getters.mapStyle} mapboxApiAccessToken={MAPBOX_TOKEN} />\n      }\n    </DeckGL>\n  )\n\n  return deckInstance\n}\n","<template lang=\"pug\">\n.mymaplibre-map(:id=\"containerId\")\n  .mymap(:id=\"mapId\")\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport maplibregl, { MapMouseEvent, PositionOptions } from 'maplibre-gl'\n\nimport globalStore from '@/store'\nimport { ColorScheme } from '@/Globals'\n\nconst Component = defineComponent({\n  name: 'BackgroundMapOnTop',\n  components: {},\n  data: () => {\n    return {\n      containerId: `c${Math.floor(1e12 * Math.random())}`,\n      globalState: globalStore.state,\n      isDarkMode: false,\n      isMapMoving: false,\n      mapId: `map-${Math.floor(1e12 * Math.random())}`,\n      mymap: {} as maplibregl.Map,\n      resizer: null as ResizeObserver | null,\n    }\n  },\n  computed: {},\n  methods: {\n    setupResizer() {\n      this.resizer = new ResizeObserver(() => {\n        this.mymap.resize()\n      })\n\n      const viz = document.getElementById(this.containerId) as HTMLElement\n      this.resizer.observe(viz)\n    },\n    handleMapMotion() {\n      const mapCamera = {\n        longitude: this.mymap.getCenter().lng,\n        latitude: this.mymap.getCenter().lat,\n        bearing: this.mymap.getBearing(),\n        zoom: this.mymap.getZoom(),\n        pitch: this.mymap.getPitch(),\n      }\n\n      this.$store.commit('setMapCamera', mapCamera)\n      if (!this.isMapMoving) this.isMapMoving = true\n    },\n\n    async setupMap() {\n      const styles = globalStore.state.mapStyles\n      try {\n        this.mymap = new maplibregl.Map({\n          container: this.mapId,\n          style: this.isDarkMode ? styles.transparentDark : styles.transparentLight,\n          logoPosition: 'top-left',\n        })\n\n        // make sure it starts up aligned with main map\n        const view = { ...this.globalState.viewState } as any\n        this.mymap.jumpTo(view)\n      } catch (e) {\n        console.error('HUH?' + e)\n        return\n      }\n\n      // Start doing stuff AFTER the MapLibre library has fully initialized\n      this.mymap.on('load', this.mapIsReady)\n      this.mymap.on('move', this.handleMapMotion)\n\n      // We are always in thumbnail mode oo-/\n      // if (this.thumbnail) {\n      if (true) {\n        let baubles = document.getElementsByClassName(\n          'mapboxgl-ctrl mapboxgl-ctrl-attrib mapboxgl-compact'\n        )\n        for (const elem of baubles) elem.setAttribute('style', 'display: none')\n\n        baubles = document.getElementsByClassName('mapboxgl-ctrl mapboxgl-ctrl-group')\n        for (const elem of baubles) elem.setAttribute('style', 'display: none')\n\n        baubles = document.getElementsByClassName('mapboxgl-ctrl-logo')\n        for (const elem of baubles) elem.setAttribute('style', 'display: none')\n      } else {\n        let baubles = document.getElementsByClassName('mapboxgl-ctrl-logo')\n        for (const elem of baubles) elem.setAttribute('style', 'margin-bottom: 3rem;')\n      }\n    },\n\n    async mapIsReady() {\n      this.setupResizer()\n    },\n\n    viewMoved(value: any) {\n      if (!this.mymap || this.isMapMoving) {\n        this.isMapMoving = false\n        return\n      }\n\n      const { bearing, longitude, latitude, zoom, pitch } = value\n\n      // sometimes closing a view returns a null map, ignore it!\n      if (!zoom) return\n\n      this.mymap.off('move', this.handleMapMotion)\n\n      this.mymap.jumpTo({\n        bearing,\n        zoom,\n        center: [longitude, latitude],\n        pitch,\n      })\n\n      this.mymap.on('move', this.handleMapMotion)\n    },\n  },\n  watch: {\n    '$store.state.viewState'(value: any) {\n      this.viewMoved(value)\n    },\n\n    '$store.state.colorScheme'() {\n      this.isDarkMode = this.$store.state.colorScheme === ColorScheme.DarkMode\n      if (!this.mymap) return\n\n      const styles = globalStore.state.mapStyles\n      this.mymap.setStyle(this.isDarkMode ? styles.transparentDark : styles.transparentLight)\n\n      this.mymap.on('style.load', () => {})\n    },\n\n    '$store.state.resizeEvents'() {\n      if (this.mymap) this.mymap.resize()\n    },\n  },\n  async mounted() {\n    this.isDarkMode = this.$store.state.colorScheme === ColorScheme.DarkMode\n    this.setupMap()\n  },\n})\nexport default Component\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.mymaplibre-map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  pointer-events: none;\n}\n\n.mymap {\n  height: 100%;\n}\n</style>\n","<template lang=\"pug\">\n.join-picker\n  .picker-panel\n    p.header: b Select ID Column\n    p.subheader Which property contains the unique ID for each feature?\n    .split-panel\n      .column\n          p: b {{ data1.title }}\n          .options-box\n            p(v-for=\"(row,i) in columns\" :key=\"'@'+i\"\n              :class=\"{'selected': i===selected1}\"\n              @click=\"selected1=i\"\n            ) {{ row }}\n\n    .buttons\n      .button-holder\n        button.button(@click=\"clickedCancel\") Cancel\n        button.button.is-primary(@click=\"clickedJoin\") Select\n\n</template>\n\n<script lang=\"ts\">\nconst i18n = {\n  messages: {\n    en: {},\n    de: {},\n  },\n}\n\ninterface DataSet {\n  title: string\n  columns: string[]\n}\n\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\n// Reasonable guesses as to the ID column in the shapefile\nconst ID_GUESSES = ['id', 'ID', 'TAZ', 'AB']\n\nexport default defineComponent({\n  name: 'ModalJoinColumnPicker',\n  i18n,\n  props: {\n    data1: { type: Object as PropType<DataSet>, required: true },\n  },\n\n  data() {\n    return {\n      selected1: 0,\n    }\n  },\n\n  computed: {\n    columns(): string[] {\n      return [...this.data1.columns].sort()\n    },\n  },\n\n  methods: {\n    clickedJoin() {\n      this.$emit('join', this.columns[this.selected1])\n    },\n\n    clickedCancel() {\n      this.$emit('join', '')\n    },\n  },\n  mounted() {\n    // pick a plausible default for the ID column\n    for (const guess of ID_GUESSES) {\n      const found = this.columns.indexOf(guess)\n      if (found > -1) {\n        this.selected1 = found\n        break\n      }\n    }\n  },\n})\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.join-picker {\n  background-color: #000022aa;\n  z-index: 10000;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  user-select: none;\n  color: #333;\n}\n\n.picker-panel {\n  position: relative;\n  top: 25%;\n  background-color: #dcdce9;\n  max-width: 30rem;\n  margin: 0 auto;\n  box-shadow: 0 2px 24px 5px #00000066;\n  border-radius: 4px;\n}\n\n.split-panel {\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n}\n\n.column {\n  padding: 0 0;\n  margin: 0.5rem 0.75rem;\n}\n\n.options-box {\n  border: 1px solid #bbb;\n  background-color: white;\n  max-height: 20rem;\n  overflow-y: auto;\n}\n\n.options-box p {\n  padding: 0 0.25rem;\n}\n\n.linky {\n  margin-top: 3rem;\n}\n\n.header {\n  background-color: white;\n  padding: 0.25rem 0.75rem;\n  border-radius: 4px;\n  font-size: 1.2rem;\n}\n\np.selected {\n  background-color: #e8ee67;\n}\n\n.subheader {\n  padding: 0.25rem 0.75rem;\n}\n\n.button-holder {\n  margin: 0.25rem 0.75rem 0.25rem auto;\n}\n</style>\n","<template lang=\"pug\">\n.map-layout(:class=\"{'hide-thumbnail': !thumbnail}\"\n            :style='{\"background\": urlThumbnail}'\n            oncontextmenu=\"return false\")\n\n  .status-bar(v-show=\"statusText\") {{ statusText }}\n\n  modal-id-column-picker(v-if=\"showJoiner\"\n    v-bind=\"datasetJoinSelector\"\n    @join=\"cbDatasetJoined\"\n  )\n\n  .area-map(v-if=\"!thumbnail\" :id=\"`container-${layerId}`\")\n    //- drawing-tool.draw-tool(v-if=\"isLoaded && !thumbnail\")\n\n    geojson-layer(v-if=\"!needsInitialMapExtent\"\n      :viewId=\"layerId\"\n      :fillColors=\"dataFillColors\"\n      :featureDataTable=\"boundaryDataTable\"\n      :lineColors=\"dataLineColors\"\n      :lineWidths=\"dataLineWidths\"\n      :fillHeights=\"dataFillHeights\"\n      :screenshot=\"triggerScreenshot\"\n      :calculatedValues=\"dataCalculatedValues\"\n      :calculatedValueLabel=\"dataCalculatedValueLabel\"\n      :normalizedValues=\"dataNormalizedValues\"\n      :featureFilter=\"boundaryFilters\"\n      :opacity=\"sliderOpacity\"\n      :pointRadii=\"dataPointRadii\"\n      :tooltip=\"vizDetails.tooltip\"\n      :cbTooltip=\"cbTooltip\"\n    )\n    //- :features=\"useCircles ? centroids: boundaries\"\n\n    //- background-map-on-top(v-if=\"isLoaded\")\n\n    viz-configurator(v-if=\"isLoaded\"\n      :embedded=\"isEmbedded\"\n      :sections=\"configuratorSections\"\n      :fileSystem=\"fileSystem\"\n      :subfolder=\"subfolder\"\n      :yamlConfig=\"generatedExportFilename\"\n      :vizDetails=\"vizDetails\"\n      :datasets=\"datasets\"\n      :legendStore=\"legendStore\"\n      :filterDefinitions=\"currentUIFilterDefinitions\"\n      @update=\"changeConfiguration\"\n      @screenshot=\"takeScreenshot\"\n    )\n\n    .details-panel(v-if=\"tooltipHtml && !statusText\" v-html=\"tooltipHtml\")\n\n  zoom-buttons(v-if=\"isLoaded && !thumbnail\")\n\n  .config-bar(v-if=\"!thumbnail && !isEmbedded && isLoaded && Object.keys(filters).length\"\n    :class=\"{'is-standalone': !configFromDashboard, 'is-disabled': !isLoaded}\")\n\n    //- Filter pickers\n    .filter(v-for=\"filter in Object.keys(filters)\")\n      p {{ filter }}\n      b-dropdown(\n        v-model=\"filters[filter].active\"\n        :scrollable=\"filters[filter].active.length > 10\"\n        max-height=\"250\"\n        multiple\n        @change=\"handleUserSelectedNewFilters(filter)\"\n        aria-role=\"list\" :mobile-modal=\"false\" :close-on-click=\"true\"\n      )\n        template(#trigger=\"{ active }\")\n          b-button.is-primary(\n            :type=\"filters[filter].active.length ? '' : 'is-outlined'\"\n            :label=\"filterLabel(filter)\"\n          )\n\n        b-dropdown-item(v-for=\"option in filters[filter].options\"\n          :key=\"option\" :value=\"option\" aria-role=\"listitem\") {{ option }}\n\n    //- .map-type-buttons(v-if=\"isAreaMode\")\n    //-   img.img-button(@click=\"showCircles(false)\" src=\"../../assets/btn-polygons.jpg\" title=\"Shapes\")\n    //-   img.img-button(@click=\"showCircles(true)\" src=\"../../assets/btn-circles.jpg\" title=\"Circles\")\n\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\nimport { group, zip, sum } from 'd3-array'\n\nimport readBlob from 'read-blob'\nimport reproject from 'reproject'\nimport Sanitize from 'sanitize-filename'\nimport * as shapefile from 'shapefile'\nimport * as turf from '@turf/turf'\nimport YAML from 'yaml'\n\nimport globalStore from '@/store'\nimport {\n  DataTable,\n  DataTableColumn,\n  DataType,\n  FileSystemConfig,\n  VisualizationPlugin,\n  DEFAULT_PROJECTION,\n  REACT_VIEW_HANDLES,\n  Status,\n} from '@/Globals'\n\nimport GeojsonLayer from './GeojsonLayer'\nimport BackgroundMapOnTop from '@/components/BackgroundMapOnTop.vue'\nimport ColorWidthSymbologizer from '@/js/ColorsAndWidths'\nimport VizConfigurator from '@/components/viz-configurator/VizConfigurator.vue'\nimport ModalIdColumnPicker from './ModalIdColumnPicker.vue'\nimport ZoomButtons from '@/components/ZoomButtons.vue'\nimport DrawingTool from '@/components/DrawingTool/DrawingTool.vue'\n\nimport HTTPFileSystem from '@/js/HTTPFileSystem'\nimport DashboardDataManager, { FilterDefinition, checkFilterValue } from '@/js/DashboardDataManager'\nimport { arrayBufferToBase64 } from '@/js/util'\nimport { CircleRadiusDefinition } from '@/components/viz-configurator/CircleRadius.vue'\nimport { FillColorDefinition } from '@/components/viz-configurator/FillColors.vue'\nimport { LineColorDefinition } from '@/components/viz-configurator/LineColors.vue'\nimport { LineWidthDefinition } from '@/components/viz-configurator/LineWidths.vue'\nimport { FillHeightDefinition } from '@/components/viz-configurator/FillHeight.vue'\nimport { DatasetDefinition } from '@/components/viz-configurator/AddDatasets.vue'\nimport Coords from '@/js/Coords'\nimport LegendStore from '@/js/LegendStore'\n\ninterface FilterDetails {\n  column: string\n  label?: string\n  options: any[]\n  active: any[]\n  dataset?: any\n}\n\nconst MyComponent = defineComponent({\n  name: 'ShapeFilePlugin',\n  components: {\n    BackgroundMapOnTop,\n    GeojsonLayer,\n    ModalIdColumnPicker,\n    VizConfigurator,\n    ZoomButtons,\n    DrawingTool,\n  },\n\n  props: {\n    root: { type: String, required: true },\n    subfolder: { type: String, required: true },\n    datamanager: { type: Object as PropType<DashboardDataManager> },\n    configFromDashboard: { type: Object as any },\n    yamlConfig: String,\n    thumbnail: Boolean,\n    // fsConfig: { type: Object as PropType<FileSystemConfig> },\n  },\n\n  data() {\n    return {\n      boundaries: [] as any[],\n      centroids: [] as any[],\n      cbDatasetJoined: undefined as any,\n      legendStore: new LegendStore(),\n      chosenNewFilterColumn: '',\n      boundaryDataTable: {} as DataTable,\n      dataFillColors: '#888' as string | Uint8Array,\n      dataLineColors: '' as string | Uint8Array,\n      dataLineWidths: 1 as number | Float32Array,\n      dataPointRadii: 5 as number | Float32Array,\n      dataFillHeights: 0 as number | Float32Array,\n      dataCalculatedValues: null as Float32Array | null,\n      dataNormalizedValues: null as Float32Array | null,\n      constantLineWidth: null as null | number,\n      dataCalculatedValueLabel: '',\n\n      globalStore,\n      globalState: globalStore.state,\n      layerId: Math.floor(1e12 * Math.random()),\n\n      activeColumn: '',\n      useCircles: false,\n      sliderOpacity: 100,\n\n      maxValue: 1000,\n      expColors: false,\n      isLoaded: false,\n      isAreaMode: true,\n      statusText: 'Loading...',\n\n      // Filters. Key is column id; value array is empty for \"all\" or a list of \"or\" values\n      filters: {} as { [column: string]: FilterDetails },\n\n      needsInitialMapExtent: true,\n      datasetJoinColumn: '',\n      featureJoinColumn: '',\n      triggerScreenshot: 0,\n\n      datasetKeyToFilename: {} as any,\n\n      datasetJoinSelector: {} as { [id: string]: { title: string; columns: string[] } },\n      showJoiner: false,\n\n      // DataManager might be passed in from the dashboard; or we might be\n      // in single-view mode, in which case we need to create one for ourselves\n      myDataManager: this.datamanager || new DashboardDataManager(this.root, this.subfolder),\n\n      config: {} as any,\n      // these are the settings defined in the UI\n      currentUIFilterDefinitions: {} as any,\n      currentUIFillColorDefinitions: {} as any,\n      currentUILineColorDefinitions: {} as any,\n\n      // these are the processed filter defs passed to the data manager\n      filterDefinitions: [] as FilterDefinition[],\n\n      isEmbedded: false,\n      resizer: null as null | ResizeObserver,\n      boundaryFilters: new Float32Array(0),\n      thumbnailUrl: \"url('assets/thumbnail.jpg') no-repeat;\",\n      boundaryJoinLookups: {} as { [column: string]: { [lookup: string | number]: number } },\n      datasetValuesColumn: '',\n\n      tooltipHtml: '',\n\n      vizDetails: {\n        title: '',\n        description: '',\n        datasets: {} as { [id: string]: { file: string; join: string } },\n        useSlider: false,\n        showDifferences: false,\n        shpFile: '',\n        dbfFile: '',\n        network: '',\n        geojsonFile: '',\n        projection: '',\n        widthFactor: null as any,\n        thumbnail: '',\n        sum: false,\n        filters: [] as { [filterId: string]: any }[],\n        shapes: '' as string | { file: string; join: string },\n        zoom: null as number | null,\n        center: null as any[] | null,\n        pitch: null as number | null,\n        bearing: null as number | null,\n        display: {\n          fill: {} as any,\n          fillHeight: {} as any,\n          color: {} as any,\n          width: {} as any,\n          lineColor: {} as any,\n          lineWidth: {} as any,\n          radius: {} as any,\n        },\n        tooltip: [] as string[],\n      },\n\n      datasets: {} as { [id: string]: DataTable },\n    }\n  },\n\n  computed: {\n    fileApi(): HTTPFileSystem {\n      return new HTTPFileSystem(this.fileSystem, globalStore)\n    },\n\n    fileSystem(): FileSystemConfig {\n      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(\n        (a: FileSystemConfig) => a.slug === this.root\n      )\n      if (svnProject.length === 0) {\n        console.log('no such project')\n        throw Error\n      }\n      return svnProject[0]\n    },\n\n    configuratorSections(): string[] {\n      if (this.isAreaMode)\n        return ['fill-color', 'fill-height', 'line-color', 'line-width', 'circle-radius', 'filters']\n      else return ['line-color', 'line-width', 'filters']\n    },\n\n    datasetChoices(): string[] {\n      return Object.keys(this.datasets)\n    },\n\n    generatedExportFilename(): string {\n      let filename = Sanitize(this.yamlConfig ?? '')\n      filename = filename.replaceAll(' ', '-')\n\n      if (!filename.startsWith('viz-map-')) filename = 'viz-map-' + filename\n      if (!filename.endsWith('.yml') && !filename.endsWith('.yaml')) filename = filename + '.yaml'\n\n      return filename\n    },\n\n    urlThumbnail(): string {\n      return this.thumbnailUrl\n    },\n  },\n\n  watch: {\n    'globalState.viewState'() {\n      if (!REACT_VIEW_HANDLES[this.layerId]) return\n      REACT_VIEW_HANDLES[this.layerId]()\n    },\n\n    'globalState.colorScheme'() {\n      // change one element to force a deck.gl redraw\n      this.$nextTick().then(p => {\n        const tooltips = this.vizDetails.tooltip || []\n        this.vizDetails.tooltip = [...tooltips]\n      })\n    },\n  },\n\n  methods: {\n    // incrementing screenshot count triggers the screenshot.\n    takeScreenshot() {\n      this.triggerScreenshot++\n    },\n\n    setEmbeddedMode() {\n      if ('embed' in this.$route.query) {\n        console.log('EMBEDDED MODE')\n        this.isEmbedded = true\n        this.$store.commit('setShowLeftBar', false)\n        this.$store.commit('setFullWidth', true)\n      }\n    },\n\n    setupLogoMover() {\n      this.resizer = new ResizeObserver(this.moveLogo)\n      const deckmap = document.getElementById(`container-${this.layerId}`) as HTMLElement\n      this.resizer.observe(deckmap)\n    },\n\n    moveLogo() {\n      const deckmap = document.getElementById(`container-${this.layerId}`) as HTMLElement\n      const logo = deckmap?.querySelector('.mapboxgl-ctrl-bottom-left') as HTMLElement\n      if (logo) {\n        const right = deckmap.clientWidth > 640 ? '280px' : '36px'\n        logo.style.right = right\n      }\n    },\n\n    columnsInDataset(datasetId: string) {\n      const data = this.datasets[datasetId]\n      return Object.keys(data)\n    },\n\n    filterShapesNow() {\n      // shape filters only\n      const shapeFilters = this.filterDefinitions.filter(f => f.dataset === 'shapes')\n\n      this.boundaryFilters = new Float32Array(this.boundaries.length)\n\n      // show all elements if there are no shapefilters defined\n      if (!shapeFilters.length) return\n\n      const isLTGT = /^(<|>)/ // starts with < or >\n\n      for (const filter of shapeFilters) {\n        // console.log('filter >>>:', filter)\n        let spec = filter.value\n        let conditional = ''\n\n        // check categorical\n        if (spec == '@categorical') {\n          conditional = '@categorical'\n          spec = ''\n        }\n        // check LT/GT\n        else if (isLTGT.test(spec)) {\n          if (spec.startsWith('<=')) {\n            conditional = '<='\n            spec = parseFloat(spec.substring(2).trim())\n          } else if (spec.startsWith('>=')) {\n            conditional = '>='\n            spec = parseFloat(spec.substring(2).trim())\n          } else if (spec.startsWith('<')) {\n            conditional = '<'\n            spec = parseFloat(spec.substring(1).trim())\n          } else if (spec.startsWith('>')) {\n            conditional = '>'\n            spec = parseFloat(spec.substring(1).trim())\n          }\n        }\n        // handle case where we are testing equal/inequal and its a \"numeric\" string\n        else {\n          if (typeof spec === 'string') {\n            // handle a comma-separated list\n            if (spec.indexOf(',') > -1) {\n              spec = spec\n                .split(',')\n                .map(v => v.trim())\n                .map(v => (Number.isNaN(parseFloat(v)) ? v : parseFloat(v)))\n            } else {\n              const numericString = parseFloat(spec)\n              if (!Number.isNaN(numericString)) spec = numericString\n            }\n          }\n        }\n\n        if (!Array.isArray(spec)) spec = [spec]\n\n        const fullSpecification = { conditional, invert: filter.invert || false, values: spec }\n        // console.log('HEREWEGO: ', fullSpecification)\n        const dataColumnValues = this.boundaryDataTable[filter.column].values\n\n        // update every row\n        for (let i = 0; i < this.boundaries.length; i++) {\n          if (!checkFilterValue(fullSpecification, dataColumnValues[i])) {\n            this.boundaryFilters[i] = -1\n          }\n        }\n      }\n    },\n\n    cbTooltip(html: string) {\n      this.tooltipHtml = html\n    },\n\n    filterShapesNowOriginal() {\n      // shape filters only\n      const shapeFilters = this.filterDefinitions.filter(f => f.dataset === 'shapes')\n\n      this.boundaryFilters = new Float32Array(this.boundaries.length)\n\n      // show all elements if there are no shapefilters defined\n      if (!shapeFilters.length) return\n\n      // console.log({ shapeFilters, length: this.boundaries.length })\n\n      // loop on all boundaries and centroids\n      for (let i = 0; i < this.boundaries.length; i++) {\n        for (const filter of shapeFilters) {\n          const hideElement = !this.checkIsFiltered(i, filter)\n          if (hideElement) this.boundaryFilters[i] = -1\n        }\n      }\n    },\n\n    checkIsFiltered(i: number, filter: FilterDefinition) {\n      const dataset =\n        filter.dataset == 'shapes' ? this.boundaryDataTable : this.datasets[filter.dataset]\n      const actualValue = dataset[filter.column].values[i]\n\n      let includeElement = false\n\n      let filterValue = filter.value\n      if (typeof filterValue == 'string' && filterValue.indexOf(',') > -1) {\n        filterValue = filterValue\n          .split(',')\n          .map(v => v.trim())\n          .map(v => (isNaN(parseFloat(v)) ? v : parseFloat(v)))\n      }\n\n      if (Array.isArray(filterValue)) {\n        // 1. filter is an array of categories\n        includeElement = filterValue.indexOf(actualValue) > -1\n      } else {\n        // 2. filter is a string: exact value or CSV\n        includeElement = filterValue == actualValue\n      }\n\n      // Invert if inverted\n      if (filter.invert) includeElement = !includeElement\n\n      return includeElement\n    },\n\n    parseFilterDefinitions(filterDefs: any) {\n      // no filters? go away\n      if (!filterDefs) return []\n\n      const filters = [] as FilterDefinition[]\n\n      // User may have specified an array or an object:\n      let filterSpecs: any[]\n      if (Array.isArray(filterDefs)) {\n        filterSpecs = filterDefs.map(f => Object.entries(f)[0])\n      } else {\n        filterSpecs = Object.entries(filterDefs)\n      }\n\n      for (const filter of filterSpecs) {\n        const [id, value] = filter\n        const [dataset, column] = id.split('.')\n        const filterDefinition: FilterDefinition = {\n          dataset,\n          value,\n          column: column.endsWith('!') ? column.substring(0, column.length - 1) : column,\n          invert: column.endsWith('!'),\n        }\n        filters.push(filterDefinition)\n\n        // // categorical filters may already have UI settings that need merging\n        // if (column in this.filters) {\n        //   filterDefinition.....\n        // }\n      }\n\n      return filters\n    },\n\n    honorQueryParameters() {\n      const query = this.$route.query\n      if (query.show == 'dots') this.useCircles = true\n\n      // this.setupQueryFilters()\n    },\n\n    // perhaps we have some active filters in the URL query\n    setupQueryFilters() {\n      const datasetKeys = Object.keys(this.datasets)\n      // TODO - make this multi-dataset aware  // 2 means shapes + dataset #1.\n      if (datasetKeys.length !== 2) return\n\n      const firstDatasetKey = datasetKeys[1]\n      const firstDataset = this.datasets[firstDatasetKey]\n\n      const columnNames = Object.keys(firstDataset)\n\n      const queryFilters = Object.keys(this.$route.query).filter(f => columnNames.indexOf(f) > -1)\n\n      for (const column of queryFilters) {\n        if (!this.filters[column]) {\n          console.log('CREATING category filter:', column)\n          this.handleUserCreatedNewFilter(`${firstDatasetKey}:${column}`)\n        }\n\n        const text = '' + this.$route.query[column]\n        if (text) this.filters[column].active = text.split(',')\n\n        this.myDataManager.setFilter({\n          dataset: this.datasetKeyToFilename[firstDatasetKey],\n          column,\n          value: this.filters[column].active,\n        })\n        this.activateFiltersForDataset(firstDatasetKey)\n      }\n    },\n\n    convertCommasToArray(thing: any): any[] {\n      if (thing === undefined) return []\n      if (Array.isArray(thing)) return thing\n\n      if (thing.indexOf(',') > -1) {\n        thing = thing.split(',').map((f: any) => f.trim())\n      } else {\n        thing = [thing.trim()]\n      }\n      return thing\n    },\n\n    async getVizDetails() {\n      const emptyState = {\n        datasets: {} as any,\n        display: { fill: {} as any },\n      }\n\n      // are we in a dashboard?\n      if (this.configFromDashboard) {\n        this.config = JSON.parse(JSON.stringify(this.configFromDashboard))\n        this.vizDetails = Object.assign({}, emptyState, this.configFromDashboard)\n      } else {\n        // was a YAML file was passed in?\n        const filename = (this.yamlConfig ?? '').toLocaleLowerCase()\n\n        if (filename?.endsWith('yaml') || filename?.endsWith('yml')) {\n          const ycfg = await this.loadYamlConfig()\n          this.config = ycfg\n          this.vizDetails = Object.assign({}, emptyState, ycfg)\n        }\n\n        // OR is this a bare geojson/shapefile file? - build vizDetails manually\n        if (/(\\.geojson)(|\\.gz)$/.test(filename) || /\\.shp$/.test(filename)) {\n          const title = `${filename.endsWith('shp') ? 'Shapefile' : 'GeoJSON'}: ${this.yamlConfig}`\n\n          this.vizDetails = Object.assign({}, emptyState, this.vizDetails, {\n            title,\n            description: this.subfolder,\n            shapes: this.yamlConfig,\n          })\n\n          this.config = JSON.parse(JSON.stringify(this.vizDetails))\n        }\n      }\n\n      const t = this.vizDetails.title || 'Map'\n      this.$emit('title', t)\n    },\n\n    // figure out old-style joins\n    buildOldJoinLookups() {\n      const oldJoinFieldPerDataset = {} as any\n\n      for (const dataset of Object.keys(this.vizDetails.datasets || [])) {\n        const join = this.vizDetails.datasets[dataset].join\n        if (!join) continue\n\n        const colon = join.indexOf(':')\n        oldJoinFieldPerDataset[dataset] = join.substring(colon + 1)\n        if (typeof this.vizDetails.shapes == 'string') {\n          const shapeJoinField = colon > -1 ? join.substring(0, colon) : join\n          this.vizDetails.shapes = { file: this.vizDetails.shapes, join: shapeJoinField }\n        }\n      }\n\n      // apply old-style joins to elements\n      for (const section of Object.keys(this.vizDetails.display || [])) {\n        const display = this.vizDetails.display as any\n        const details = display[section]\n        if ((details.dataset || details.diff) && !details.join) {\n          details.join = oldJoinFieldPerDataset[details.dataset]\n        }\n      }\n    },\n\n    async buildThumbnail() {\n      if (this.thumbnail && this.vizDetails.thumbnail) {\n        try {\n          const blob = await this.fileApi.getFileBlob(\n            this.subfolder + '/' + this.vizDetails.thumbnail\n          )\n          const buffer = await readBlob.arraybuffer(blob)\n          const base64 = arrayBufferToBase64(buffer)\n          if (base64)\n            this.thumbnailUrl = `center / cover no-repeat url(data:image/png;base64,${base64})`\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n\n    getFileSystem(name: string) {\n      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(\n        (a: FileSystemConfig) => a.slug === name\n      )\n      if (svnProject.length === 0) {\n        console.log('no such project')\n        throw Error\n      }\n      return svnProject[0]\n    },\n\n    async loadYamlConfig() {\n      const config = this.yamlConfig ?? ''\n      const filename = config.indexOf('/') > -1 ? config : this.subfolder + '/' + config\n\n      // 1. First try loading the file directly\n      try {\n        const text = await this.fileApi.getFileText(filename)\n        return YAML.parse(text)\n      } catch (err) {\n        const message = '' + err\n        if (message.startsWith('YAMLSemantic')) {\n          this.$emit('error', `${filename}: ${message}`)\n        }\n        console.log(`${filename} not found, trying config folders`)\n      }\n\n      // 2. Try loading from a config folder instead\n      const { vizes } = await this.fileApi.findAllYamlConfigs(this.subfolder)\n      if (vizes[config]) {\n        try {\n          const text = await this.fileApi.getFileText(vizes[config])\n          return YAML.parse(text)\n        } catch (err) {\n          console.error(`Also failed to load ${vizes[config]}`)\n        }\n      }\n      this.$emit('error', 'Could not load YAML: ' + filename)\n    },\n\n    /**\n     * changeConfiguration: is the main entry point for changing the viz model.\n     * anything that wants to change colors, widths, data, anthing like that\n     * should all pass through this function so the underlying data model\n     * is modified properly.\n     */\n    changeConfiguration(props: {\n      fill?: FillColorDefinition\n      dataset?: DatasetDefinition\n      lineColor?: LineColorDefinition\n      lineWidth?: LineWidthDefinition\n      radius?: CircleRadiusDefinition\n      fillHeight?: FillHeightDefinition\n      filters?: FilterDefinition\n    }) {\n      console.log('PROPS', props)\n\n      try {\n        if (props['fill']) {\n          this.vizDetails.display.fill = props.fill\n          this.handleNewFillColor(props.fill)\n        }\n\n        if (props['fillHeight']) {\n          this.vizDetails.display.fillHeight = props.fillHeight\n          this.handleNewFillHeight(props.fillHeight)\n        }\n\n        if (props['lineColor']) {\n          this.vizDetails.display.lineColor = props.lineColor\n          this.handleNewLineColor(props.lineColor)\n        }\n\n        if (props['lineWidth']) {\n          this.vizDetails.display.lineWidth = props.lineWidth\n          this.handleNewLineWidth(props.lineWidth)\n          // redo colors after widths to ensure categorical widths are set properly\n          if (this.currentUILineColorDefinitions)\n            this.handleNewLineColor(this.currentUILineColorDefinitions)\n        }\n\n        if (props['radius']) {\n          this.vizDetails.display.radius = props.radius\n          this.handleNewRadius(props.radius)\n        }\n\n        if (props['dataset']) {\n          // vizdetails just had the string name, whereas props.dataset contains\n          // a fully-build DatasetDefinition, so let's just handle that\n          this.handleNewDataset(props.dataset)\n        }\n\n        if (props['filters']) {\n          this.handleNewFilters(props.filters)\n        }\n\n        // console.log('DONE updating')\n      } catch (e) {\n        this.$emit('error', '' + e)\n      }\n    },\n\n    async handleNewDataset(props: DatasetDefinition) {\n      const { key, dataTable, filename } = props\n      const datasetId = key\n      const datasetFilename = filename || datasetId\n\n      console.log('HANDLE NEW DATSET:', datasetId, datasetFilename)\n\n      if (!this.boundaryDataTable[this.featureJoinColumn])\n        throw Error(`Geodata does not have property ${this.featureJoinColumn}`)\n\n      this.myDataManager.setPreloadedDataset({\n        key: this.datasetKeyToFilename[datasetId],\n        dataTable,\n      })\n\n      this.myDataManager.addFilterListener(\n        { dataset: this.datasetKeyToFilename[datasetId] },\n        this.processFiltersNow\n      )\n\n      this.vizDetails.datasets[datasetId] = {\n        file: datasetFilename,\n        // if join columns are not named identically, use \"this:that\" format\n        // join:\n        //   featureJoinColumn === dataJoinColumn\n        //     ? featureJoinColumn\n        //     : `${featureJoinColumn}:${dataJoinColumn}`,\n      } as any\n\n      this.vizDetails = Object.assign({}, this.vizDetails)\n      this.datasets[datasetId] = dataTable\n      this.datasets = Object.assign({}, this.datasets)\n    },\n\n    setupJoin(props: { dataTable: DataTable; datasetId: string; dataJoinColumn: string }) {\n      const { dataTable, datasetId, dataJoinColumn } = props\n      // console.log('> setupJoin', datasetId, dataJoinColumn)\n\n      // if no join at all, don't do anything\n      if (!dataJoinColumn) return\n\n      // if join already exists, don't do anything\n      if (`@@${dataJoinColumn}` in dataTable) return\n\n      // make sure columns exist!\n      if (!this.boundaryDataTable[this.featureJoinColumn])\n        throw Error(`Geodata does not have property ${this.featureJoinColumn}`)\n      if (!dataTable[dataJoinColumn])\n        throw Error(`Dataset ${datasetId} does not have column ${dataJoinColumn}`)\n\n      // create lookup column and write lookup offsets\n      const lookupColumn: DataTableColumn = {\n        type: DataType.LOOKUP,\n        values: [],\n        name: `@@${dataJoinColumn}`,\n      }\n\n      const lookupValues = dataTable[dataJoinColumn].values\n\n      const boundaryOffsets = this.getBoundaryOffsetLookup(this.featureJoinColumn)\n      // if user wants specific tooltips based on this dataset, save the values\n      // TODO - this is in the wrong place and probably causes problems with\n      // multi-line datasets\n\n      const tips = this.vizDetails.tooltip || []\n      const relevantTips = tips\n        .filter(tip => tip.substring(0, tip.indexOf('.')).startsWith(datasetId))\n        .map(tip => {\n          return { id: tip, column: tip.substring(1 + tip.indexOf('.')) }\n        })\n\n      for (const tip of relevantTips) {\n        // make sure tip column exists\n        if (!dataTable[tip.column]) {\n          this.$emit('error', {\n            type: Status.WARNING,\n            msg: `Tooltip references \"${tip.id}\" but that column doesn't exist`,\n            desc: `Check the tooltip spec and column names`,\n          })\n        }\n      }\n\n      for (let i = 0; i < lookupValues.length; i++) {\n        // set lookup data\n        const featureOffset = boundaryOffsets[lookupValues[i]]\n        lookupColumn.values[i] = featureOffset\n        const feature = this.boundaries[featureOffset]\n        // also set tooltip data\n        for (const tip of relevantTips) {\n          if (!dataTable[tip.column]) continue\n          const value = dataTable[tip.column]?.values[i] && ''\n          if (feature && value) feature.properties[tip.id] = value\n        }\n      }\n\n      // Notify Deck.gl of the new tooltip data\n      if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n        REACT_VIEW_HANDLES[1000 + this.layerId](this.boundaries)\n      }\n\n      // add/replace this dataset in the datamanager, with the new lookup column\n      dataTable[`@@${dataJoinColumn}`] = lookupColumn\n      this.myDataManager.setPreloadedDataset({\n        key: this.datasetKeyToFilename[datasetId],\n        dataTable,\n      })\n\n      this.myDataManager.addFilterListener(\n        { dataset: this.datasetKeyToFilename[datasetId] },\n        this.processFiltersNow\n      )\n\n      this.vizDetails.datasets[datasetId] = {\n        file: this.datasetKeyToFilename[datasetId],\n        // if join columns are not named identically, use \"this:that\" format\n        join:\n          this.featureJoinColumn === dataJoinColumn\n            ? this.featureJoinColumn\n            : `${this.featureJoinColumn}:${dataJoinColumn}`,\n      } as any\n\n      // console.log('triggering updates')\n      this.datasets[datasetId] = dataTable\n    },\n\n    getBoundaryOffsetLookup(joinColumn: string) {\n      // return it if we already built it\n      if (this.boundaryJoinLookups[joinColumn]) return this.boundaryJoinLookups[joinColumn]\n\n      // build it\n      this.statusText = 'Joining datasets...'\n      this.boundaryJoinLookups[joinColumn] = {}\n      const lookupValues = this.boundaryJoinLookups[joinColumn]\n\n      const boundaryLookupColumnValues = this.boundaryDataTable[joinColumn].values\n\n      for (let i = 0; i < this.boundaries.length; i++) {\n        lookupValues[boundaryLookupColumnValues[i]] = i\n      }\n      this.statusText = ''\n      return lookupValues\n    },\n\n    removeAnyOldFilters(filters: any) {\n      const oldFilters = new Set(\n        Object.keys(this.currentUIFilterDefinitions).filter(f => !f.startsWith('shapes.'))\n      )\n      const newFilters = new Set(Object.keys(filters).filter(f => !f.startsWith('shapes.')))\n      newFilters.forEach(f => oldFilters.delete(f))\n\n      for (const deletedFilter of oldFilters) {\n        console.log('REMOVING', deletedFilter)\n        const dot = deletedFilter.indexOf('.')\n        const dataset = deletedFilter.slice(0, dot)\n        const column = deletedFilter.slice(dot + 1)\n        this.myDataManager.setFilter({\n          dataset: this.datasetKeyToFilename[dataset],\n          column,\n          value: [],\n        })\n\n        // also remove from category-UI and URL\n        if (column in this.filters) {\n          const query = Object.assign({}, this.$route.query)\n          delete query[column]\n          this.$router.replace({ query })\n\n          delete this.filters[column]\n        }\n      }\n    },\n\n    handleNewFilters(filters: any) {\n      // Remove removed filters first!\n      this.removeAnyOldFilters(filters)\n\n      this.currentUIFilterDefinitions = filters\n\n      const newDefinitions = this.parseFilterDefinitions(filters)\n      this.filterDefinitions = newDefinitions\n\n      // Filter the shapes/boundaries\n      this.filterShapesNow()\n\n      // Filter attached datasets\n      Object.keys(this.datasets).forEach((datasetKey, i) => {\n        if (i === 0) return // skip shapes, we just did them\n        this.activateFiltersForDataset(datasetKey)\n      })\n    },\n\n    handleColorDiffMode(section: string, color: FillColorDefinition | LineColorDefinition) {\n      if (!color.diffDatasets) return\n\n      const columnName = color.columnName\n      const lookupColumn = color.join || ''\n      const key1 = color.diffDatasets[0] || ''\n      const dataset1 = this.datasets[key1]\n      const key2 = color.diffDatasets[1] || ''\n      const dataset2 = this.datasets[key2]\n      const relative = !!color.relative\n\n      // console.log('999 DIFF', relative, key1, key2, dataset1, dataset2)\n\n      if (dataset1 && dataset2) {\n        // generate the lookup columns we need\n        this.setupJoin({ datasetId: key1, dataTable: dataset1, dataJoinColumn: lookupColumn })\n        this.setupJoin({ datasetId: key2, dataTable: dataset2, dataJoinColumn: lookupColumn })\n\n        const lookup1 = dataset1[`@@${lookupColumn}`]\n        const lookup2 = dataset2[`@@${lookupColumn}`]\n        const dataCol1 = dataset1[columnName]\n        const dataCol2 = dataset2[columnName]\n\n        if (!dataCol1) throw Error(`Dataset ${key1} does not contain column \"${columnName}\"`)\n        if (!dataCol2) throw Error(`Dataset ${key2} does not contain column \"${columnName}\"`)\n\n        // NORMALIZE if we need to\n        let normalColumn\n        let normalLookup\n\n        if (color.normalize) {\n          const [dataset, column] = color.normalize.split(':')\n          if (!this.datasets[dataset] || !this.datasets[dataset][column]) {\n            throw Error(`${dataset} does not contain column \"${column}\"`)\n          }\n          this.dataCalculatedValueLabel += `/ ${column}`\n          normalColumn = this.datasets[dataset][column]\n          // Create yet one more join for the normal column if it's not from the featureset itself\n          if (this.datasetChoices[0] !== dataset) {\n            this.setupJoin({\n              datasetId: dataset,\n              dataTable: this.datasets[dataset],\n              dataJoinColumn: lookupColumn,\n            })\n            normalLookup = this.datasets[dataset][`@@${lookupColumn}`]\n          }\n        }\n\n        // Calculate colors for each feature\n        const { array, legend, calculatedValues } = ColorWidthSymbologizer.getColorsForDataColumn({\n          numFeatures: this.boundaries.length,\n          data: dataCol1,\n          data2: dataCol2,\n          lookup: lookup1,\n          lookup2: lookup2,\n          normalize: normalColumn,\n          normalLookup,\n          options: color,\n          filter: this.boundaryFilters,\n          relative,\n        })\n\n        if (!array) return\n\n        if (section === 'fill') {\n          this.dataFillColors = array\n        } else {\n          this.dataLineColors = array\n        }\n        this.dataCalculatedValues = calculatedValues\n        this.dataCalculatedValueLabel = `${relative ? '% ' : ''}Diff: ${columnName}` // : ${key1}-${key2}`\n\n        this.legendStore.setLegendSection({\n          section: section === 'fill' ? 'FillColor' : 'Line Color',\n          column: dataCol1.name,\n          values: legend,\n          diff: true,\n          relative,\n          normalColumn: normalColumn ? normalColumn.name : '',\n        })\n      }\n    },\n\n    paintColorsWithFilter(section: string, dataTable: DataTable) {\n      const currentDefinition =\n        section === 'fill' ? this.currentUIFillColorDefinitions : this.currentUILineColorDefinitions\n\n      const columnName = currentDefinition.columnName\n      const lookupColumn =\n        currentDefinition.join === '@count'\n          ? dataTable[`@@${columnName}`]\n          : dataTable[`@@${currentDefinition.join}`]\n\n      let normalColumn\n      if (currentDefinition.normalize) {\n        const keys = currentDefinition.normalize.split(':')\n        this.dataCalculatedValueLabel = columnName + '/' + keys[1]\n        const datasetKey = currentDefinition.dataset\n\n        if (!this.datasets[keys[0]] || !this.datasets[keys[0]][keys[1]]) {\n          throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n        }\n        normalColumn = dataTable[keys[1]]\n      }\n\n      const props = {\n        numFeatures: this.boundaries.length,\n        data: dataTable[columnName],\n        normalize: normalColumn,\n        lookup: lookupColumn,\n        filter: this.boundaryFilters,\n        options: currentDefinition,\n        join: currentDefinition.join,\n      }\n\n      const { array, legend, calculatedValues } =\n        ColorWidthSymbologizer.getColorsForDataColumn(props)\n\n      if (!array) return\n\n      if (section === 'fill') {\n        this.dataFillColors = array\n      } else {\n        this.dataLineColors = array\n      }\n\n      this.dataCalculatedValues = calculatedValues\n      this.legendStore.setLegendSection({\n        section: section === 'fill' ? 'FillColor' : 'Line Color',\n        column: columnName,\n        values: legend,\n      })\n    },\n\n    handleNewFillColor(fillOrFilteredDataTable: FillColorDefinition | DataTable) {\n      // *** FILTER: if prop has a columnName, then this is a FillColorDefinition\n      const isFillColorDefinition = 'columnName' in fillOrFilteredDataTable\n      const isFilterTable = !isFillColorDefinition\n\n      // If we received a new fill color definition AND the dataset is filtered,\n      // then bookmark that definition and process the filter first/instead.\n      // (note, processFiltersNow() will call this function again once the calcs are done)\n      if (isFillColorDefinition) {\n        const dataset = fillOrFilteredDataTable?.dataset as string\n        const { filteredRows } = this.myDataManager.getFilteredDataset({\n          dataset: `${dataset}` || '',\n        })\n        if (filteredRows && filteredRows.length) {\n          this.currentUIFillColorDefinitions = fillOrFilteredDataTable\n          this.processFiltersNow(dataset)\n          return\n        }\n      }\n\n      if (isFilterTable) {\n        this.paintColorsWithFilter('fill', fillOrFilteredDataTable)\n        return\n      }\n\n      const color = fillOrFilteredDataTable as FillColorDefinition\n      this.currentUIFillColorDefinitions = color\n\n      const columnName = color.columnName\n\n      if (color.diffDatasets) {\n        // *** diff mode *************************\n        this.handleColorDiffMode('fill', color)\n        return\n      } else if (!columnName) {\n        // *** simple color **********************\n        this.dataFillColors = color.fixedColors[0]\n        this.dataCalculatedValueLabel = ''\n        this.legendStore.clear('FillColor')\n        return\n      } else {\n        // *** Data column mode ******************\n        const datasetKey = color.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n        this.dataCalculatedValueLabel = ''\n\n        // no selected dataset or datacol missing? Not sure what to do here, just give up...\n        if (!selectedDataset) {\n          console.warn('color: no selected dataset yet, maybe still loading')\n          return\n        }\n        const dataColumn = selectedDataset[columnName]\n        if (!dataColumn) {\n          throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n        }\n\n        this.dataCalculatedValueLabel = columnName ?? ''\n\n        // Do we need a join? Join it\n        let dataJoinColumn = ''\n        if (color.join && color.join !== '@count') {\n          // join column name set by user\n          dataJoinColumn = color.join\n        } else if (color.join === '@count') {\n          // rowcount specified: join on the column name itself\n          dataJoinColumn = columnName\n        } else {\n          // nothing specified: let's hope they didn't want to join\n          if (this.datasetChoices.length > 1) {\n            console.warn('No join; lets hope user just wants to display data in boundary file')\n          }\n        }\n\n        this.setupJoin({\n          datasetId: datasetKey,\n          dataTable: selectedDataset,\n          dataJoinColumn,\n        })\n\n        const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n        // Figure out the normal\n        let normalColumn\n\n        // NORMALIZE if we need to\n        let normalLookup\n        if (color.normalize) {\n          const [dataset, column] = color.normalize.split(':')\n          if (!this.datasets[dataset] || !this.datasets[dataset][column]) {\n            throw Error(`${dataset} does not contain column \"${column}\"`)\n          }\n          this.dataCalculatedValueLabel += `/ ${column}`\n          normalColumn = this.datasets[dataset][column]\n          // Create yet one more join for the normal column if it's not from the featureset itself\n          if (this.datasetChoices[0] !== dataset) {\n            this.setupJoin({\n              datasetId: dataset,\n              dataTable: this.datasets[dataset],\n              dataJoinColumn,\n            })\n            normalLookup = this.datasets[dataset][`@@${dataJoinColumn}`]\n          }\n        }\n\n        // Calculate colors for each feature\n        const { array, legend, calculatedValues, normalizedValues } =\n          ColorWidthSymbologizer.getColorsForDataColumn({\n            numFeatures: this.boundaries.length,\n            data: dataColumn,\n            normalize: normalColumn,\n            normalLookup,\n            lookup: lookupColumn,\n            filter: this.boundaryFilters,\n            options: color,\n            join: color.join,\n          })\n\n        if (array) {\n          this.dataFillColors = array\n          this.dataCalculatedValues = calculatedValues\n          this.dataNormalizedValues = normalizedValues || null\n\n          this.legendStore.setLegendSection({\n            section: 'FillColor',\n            column: dataColumn.name,\n            values: legend,\n            normalColumn: normalColumn ? normalColumn.name : '',\n          })\n        }\n      }\n    },\n\n    handleNewLineColor(colorOrFilteredDataTable: LineColorDefinition | DataTable | false) {\n      if (colorOrFilteredDataTable === false) {\n        this.dataLineColors = ''\n        this.legendStore.clear('Line Color')\n        return\n      }\n\n      // *** FILTER: if prop has a columnName, then this is a LineColorDefinition\n      const isColorDefinition = 'columnName' in colorOrFilteredDataTable\n      const isFilterTable = !isColorDefinition\n\n      // If we received a new color definition AND the dataset is filtered,\n      // then bookmark that definition and process the filter first/instead.\n      // (note, processFiltersNow() will call this function again once the calcs are done)\n      if (isColorDefinition) {\n        const dataset = colorOrFilteredDataTable?.dataset as string\n        const { filteredRows } = this.myDataManager.getFilteredDataset({\n          dataset: `${dataset}` || '',\n        })\n        if (filteredRows && filteredRows.length) {\n          this.currentUILineColorDefinitions = colorOrFilteredDataTable\n          this.processFiltersNow(dataset)\n          return\n        }\n      }\n\n      if (isFilterTable) {\n        this.paintColorsWithFilter('lineColor', colorOrFilteredDataTable)\n        return\n      }\n\n      const color = colorOrFilteredDataTable as LineColorDefinition\n      this.currentUILineColorDefinitions = color\n\n      const columnName = color.columnName\n\n      if (color.diffDatasets) {\n        // *** diff mode *************************\n        this.handleColorDiffMode('lineColor', color)\n        return\n      } else if (!columnName) {\n        // *** simple color **********************\n        this.dataLineColors = color.fixedColors[0]\n        this.dataCalculatedValueLabel = ''\n        this.legendStore.clear('Line Color')\n        return\n      } else {\n        // *** Data column mode ******************\n        const datasetKey = color.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n        this.dataCalculatedValueLabel = ''\n\n        // no selected dataset or datacol missing? Not sure what to do here, just give up...\n        if (!selectedDataset) {\n          console.warn('color: no selected dataset yet, maybe still loading')\n          return\n        }\n        const dataColumn = selectedDataset[columnName]\n        if (!dataColumn) {\n          throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n        }\n\n        this.dataCalculatedValueLabel = columnName ?? ''\n\n        // Do we need a join? Join it\n        let dataJoinColumn = ''\n        if (color.join && color.join !== '@count') {\n          // join column name set by user\n          dataJoinColumn = color.join\n        } else if (color.join === '@count') {\n          // rowcount specified: join on the column name itself\n          dataJoinColumn = columnName\n        } else {\n          // nothing specified: let's hope they didn't want to join\n          if (this.datasetChoices.length > 1) {\n            console.warn('No join; lets hope user just wants to display data in boundary file')\n          }\n        }\n\n        this.setupJoin({\n          datasetId: datasetKey,\n          dataTable: selectedDataset,\n          dataJoinColumn,\n        })\n\n        const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n        // Figure out the normal\n        let normalColumn\n\n        // NORMALIZE if we need to\n        let normalLookup\n        if (color.normalize) {\n          const [dataset, column] = color.normalize.split(':')\n          if (!this.datasets[dataset] || !this.datasets[dataset][column]) {\n            throw Error(`${dataset} does not contain column \"${column}\"`)\n          }\n          this.dataCalculatedValueLabel += `/ ${column}`\n          normalColumn = this.datasets[dataset][column]\n          // Create yet one more join for the normal column if it's not from the featureset itself\n          if (this.datasetChoices[0] !== dataset) {\n            this.setupJoin({\n              datasetId: dataset,\n              dataTable: this.datasets[dataset],\n              dataJoinColumn,\n            })\n            normalLookup = this.datasets[dataset][`@@${dataJoinColumn}`]\n          }\n        }\n\n        // Calculate colors for each feature\n        const colors = ColorWidthSymbologizer.getColorsForDataColumn({\n          numFeatures: this.boundaries.length,\n          data: dataColumn,\n          normalize: normalColumn,\n          normalLookup,\n          lookup: lookupColumn,\n          filter: this.boundaryFilters,\n          options: color,\n          join: color.join,\n        })\n\n        const { array, legend, calculatedValues, normalizedValues, hasCategory } = colors as any\n\n        if (!array) return\n\n        this.dataLineColors = array\n        this.dataCalculatedValues = calculatedValues\n        this.dataNormalizedValues = normalizedValues || null\n\n        // If colors are based on category and line widths are constant, then use a\n        // 1-pixel line width when the category is undefined.\n        if (hasCategory && this.constantLineWidth !== null) {\n          const lineWidth = this.constantLineWidth as number\n          const variableConstantWidth = new Float32Array(this.boundaries.length).fill(1)\n          Object.keys(hasCategory).forEach((i: any) => {\n            variableConstantWidth[i] = lineWidth\n          })\n          this.dataLineWidths = variableConstantWidth\n        }\n        this.legendStore.setLegendSection({\n          section: 'Line Color',\n          column: dataColumn.name,\n          values: legend,\n          normalColumn: normalColumn ? normalColumn.name : '',\n        })\n      }\n    },\n\n    handleNewLineWidth(width: LineWidthDefinition) {\n      const columnName = width.columnName || ''\n\n      // constant line width?  @0, @1, @2\n      if (width.dataset && /^@\\d$/.test(width.dataset)) {\n        this.dataLineWidths = Number.parseInt(width.dataset.substring(1))\n        this.constantLineWidth = this.dataLineWidths\n        this.legendStore.clear('Line Width')\n        return\n      } else {\n        this.constantLineWidth = null\n      }\n\n      // No scale factor?\n      if (width.scaleFactor && isNaN(width.scaleFactor)) {\n        this.dataLineWidths = 1\n        this.legendStore.clear('Line Width')\n        return\n      }\n\n      if (width.diffDatasets) {\n        const lookupColumn = width.join || ''\n        const key1 = width.diffDatasets[0] || ''\n        const dataset1 = this.datasets[key1]\n        const key2 = width.diffDatasets[1] || ''\n        const dataset2 = this.datasets[key2]\n        // const relative = !!width.relative\n\n        if (dataset1 && dataset2) {\n          // generate the lookup columns we need\n          this.setupJoin({ datasetId: key1, dataTable: dataset1, dataJoinColumn: lookupColumn })\n          this.setupJoin({ datasetId: key2, dataTable: dataset2, dataJoinColumn: lookupColumn })\n\n          const lookup1 = dataset1[`@@${lookupColumn}`]\n          const lookup2 = dataset2[`@@${lookupColumn}`]\n          const dataCol1 = dataset1[columnName]\n          const dataCol2 = dataset2[columnName]\n\n          if (!dataCol1) throw Error(`Dataset ${key1} does not contain column \"${columnName}\"`)\n          if (!dataCol2) throw Error(`Dataset ${key2} does not contain column \"${columnName}\"`)\n\n          // Calculate widths for each feature\n          const { array, legend, calculatedValues } = ColorWidthSymbologizer.getWidthsForDataColumn(\n            {\n              numFeatures: this.boundaries.length,\n              data: dataCol1,\n              data2: dataCol2,\n              lookup: lookup1,\n              lookup2: lookup2,\n              options: width,\n            }\n          )\n\n          this.dataLineWidths = array || 0\n          this.dataCalculatedValues = calculatedValues\n          this.dataCalculatedValueLabel = 'Diff: ' + columnName\n\n          this.legendStore.setLegendSection({\n            section: 'Line Width',\n            column: `${dataCol1.name} (Diff)`,\n            values: legend,\n          })\n        }\n      } else if (columnName) {\n        // Get the data column\n        const datasetKey = width.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n        if (selectedDataset) {\n          const dataColumn = selectedDataset[columnName]\n          if (!dataColumn)\n            throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n\n          // Do we need a join? Join it\n          let dataJoinColumn = ''\n          if (width.join && width.join !== '@count') {\n            // join column name set by user\n            dataJoinColumn = width.join\n          } else if (width.join === '@count') {\n            // rowcount specified: join on the column name itself\n            dataJoinColumn = columnName\n          } else {\n            // nothing specified: let's hope they didn't want to join\n            if (this.datasetChoices.length > 1) {\n              console.warn('No join; lets hope user just wants to display data in boundary file')\n            }\n          }\n\n          this.setupJoin({\n            datasetId: datasetKey,\n            dataTable: selectedDataset,\n            dataJoinColumn,\n          })\n\n          const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n          // Calculate widths for each feature\n          const { array, legend, calculatedValues } = ColorWidthSymbologizer.getWidthsForDataColumn(\n            {\n              numFeatures: this.boundaries.length,\n              data: dataColumn,\n              lookup: lookupColumn,\n              join: width.join,\n              options: width,\n            }\n          )\n\n          this.dataLineWidths = array || 0\n          this.dataCalculatedValues = calculatedValues\n          this.dataCalculatedValueLabel = columnName\n\n          if (legend.length) {\n            this.legendStore.setLegendSection({\n              section: 'Line Width',\n              column: dataColumn.name,\n              values: legend,\n            })\n          } else {\n            this.legendStore.clear('Line Width')\n          }\n        }\n      } else {\n        // simple width\n\n        this.dataLineWidths = 1\n        this.dataCalculatedValueLabel = ''\n        this.legendStore.clear('Line Width')\n      }\n      // this.filterListener()\n    },\n\n    handleNewFillHeight(height: FillHeightDefinition) {\n      const columnName = height.columnName\n      if (columnName) {\n        // Get the data column\n        const datasetKey = height.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n        if (selectedDataset) {\n          const dataColumn = selectedDataset[columnName]\n          if (!dataColumn)\n            throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n\n          // Do we need a join? Join it\n          let dataJoinColumn = ''\n          if (height.join && height.join !== '@count') {\n            // join column name set by user\n            dataJoinColumn = height.join\n          } else if (height.join === '@count') {\n            // rowcount specified: join on the column name itself\n            dataJoinColumn = columnName\n          } else {\n            // nothing specified: let's hope they didn't want to join\n            if (this.datasetChoices.length > 1) {\n              console.warn('No join; lets hope user just wants to display data in boundary file')\n            }\n          }\n\n          this.setupJoin({\n            datasetId: datasetKey,\n            dataTable: selectedDataset,\n            dataJoinColumn,\n          })\n\n          const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n          // Figure out the normal\n          let normalColumn\n          if (height.normalize) {\n            const keys = height.normalize.split(':')\n            // console.log({ keys, datasets: this.datasets })\n            if (!this.datasets[keys[0]] || !this.datasets[keys[0]][keys[1]])\n              throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n            normalColumn = this.datasets[keys[0]][keys[1]]\n            // console.log({ normalColumn })\n            this.dataCalculatedValueLabel = columnName + '/' + keys[1]\n          }\n\n          // Calculate for each feature\n          const { heights, calculatedValues, normalizedValues } =\n            ColorWidthSymbologizer.getHeightsBasedOnNumericValues({\n              length: this.boundaries.length,\n              data: dataColumn,\n              lookup: lookupColumn,\n              options: height,\n              normalize: normalColumn,\n              join: height.join,\n            })\n\n          this.dataFillHeights = heights\n          this.dataCalculatedValues = calculatedValues\n          this.dataNormalizedValues = normalizedValues || null\n          // this.dataCalculatedValueLabel = ''\n\n          if (this.$store.state.viewState.pitch == 0) {\n            const angledView = Object.assign({}, this.$store.state.viewState, {\n              pitch: 30,\n            })\n            this.$store.commit('setMapCamera', angledView)\n          }\n        }\n      } else {\n        // simple\n        this.dataFillHeights = 0\n        this.dataCalculatedValues = null\n        this.dataCalculatedValueLabel = ''\n      }\n    },\n\n    handleNewRadius(radiusOptions: CircleRadiusDefinition) {\n      const columnName = radiusOptions.columnName\n      if (columnName) {\n        // Get the data column\n        const datasetKey = radiusOptions.dataset || ''\n        const selectedDataset = this.datasets[datasetKey]\n\n        // no selected dataset or datacol missing? Not sure what to do here, just give up...\n        if (!selectedDataset) {\n          console.warn('radius: no selected dataset yet, maybe still loading')\n          return\n        }\n\n        if (selectedDataset) {\n          const dataColumn = selectedDataset[columnName]\n          if (!dataColumn)\n            throw Error(`Dataset ${datasetKey} does not contain column \"${columnName}\"`)\n\n          // Do we need a join? Join it\n          let dataJoinColumn = ''\n          if (radiusOptions.join && radiusOptions.join !== '@count') {\n            // join column name set by user\n            dataJoinColumn = radiusOptions.join\n          } else if (radiusOptions.join === '@count') {\n            // rowcount specified: join on the column name itself\n            dataJoinColumn = columnName\n          } else {\n            // nothing specified: let's hope they didn't want to join\n            if (this.datasetChoices.length > 1) {\n              console.warn('No join; lets hope user just wants to display data in boundary file')\n            }\n          }\n\n          this.setupJoin({\n            datasetId: datasetKey,\n            dataTable: selectedDataset,\n            dataJoinColumn,\n          })\n\n          const lookupColumn = selectedDataset[`@@${dataJoinColumn}`]\n\n          // Calculate radius for each feature\n          const { radius, calculatedValues } = ColorWidthSymbologizer.getRadiusForDataColumn({\n            length: this.boundaries.length,\n            data: dataColumn,\n            lookup: lookupColumn,\n            join: dataJoinColumn,\n            options: radiusOptions,\n          })\n          this.dataPointRadii = radius\n          this.dataCalculatedValues = calculatedValues\n          this.dataCalculatedValueLabel = dataColumn.name\n        }\n      } else {\n        // simple width\n        this.dataPointRadii = 5\n      }\n\n      // this.filterListener()\n\n      // set features INSIDE react component\n      if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n        REACT_VIEW_HANDLES[1000 + this.layerId](\n          typeof this.dataPointRadii == 'number' ? this.boundaries : this.centroids\n        )\n      }\n    },\n\n    async handleMapClick(click: any) {\n      try {\n        const { x, y, data } = click.points[0]\n        const filter = this.config.groupBy\n        const value = x\n\n        // this.datamanager.setFilter(this.config.dataset, filter, value)\n      } catch (e) {\n        console.error(e)\n      }\n    },\n\n    async figureOutFeatureIdColumn() {\n      // if user specified it in a data join in the YAML, we're done\n      if (this.featureJoinColumn) return this.featureJoinColumn\n\n      // if user specified it in the shapefile yaml, we're done\n      if ('string' !== typeof this.vizDetails.shapes && this.vizDetails.shapes.join) {\n        return this.vizDetails.shapes.join\n      }\n\n      // if there's only one column, we're done\n      const featureDataset = this.datasets[Object.keys(this.datasets)[0]]\n      const availableColumns = Object.keys(featureDataset)\n      if (availableColumns.length === 1) return availableColumns[0]\n\n      // ask the user\n      const join: string = await new Promise((resolve, reject) => {\n        const boundaryProperties = new Set()\n        // Some geojsons have an 'id' separate from their property table\n        if (this.boundaries[0].id) boundaryProperties.add('id')\n        // Add list of boundary properties from feature dataset\n        Object.keys(featureDataset).forEach(key => boundaryProperties.add(key))\n\n        this.datasetJoinSelector = {\n          data1: { title: 'Properties', columns: Array.from(boundaryProperties) as string[] },\n        }\n        this.showJoiner = true\n\n        this.cbDatasetJoined = (join: string) => {\n          this.datasetJoinSelector = {}\n          this.showJoiner = false\n          resolve(join)\n        }\n      })\n\n      return join.length ? join : 'id'\n    },\n\n    async processFiltersNow(datasetName?: string) {\n      // This callback occurs when there is a newly filtered dataset.\n\n      console.log('> processFiltersNow', datasetName)\n\n      const { filteredRows } = this.myDataManager.getFilteredDataset({ dataset: datasetName || '' })\n      const filteredDataTable: { [id: string]: DataTableColumn } = {}\n\n      // if we got NULL, remove this filter totally\n      if (filteredRows) {\n        // turn array of objects into data columns for consumption by fill/line/height doodads\n        // (do this here... or should this be somewhere else?)\n\n        // CONVERT array of objects to column-based DataTableColumns\n        const allColumns = filteredRows.length > 0 ? Object.keys(filteredRows[0]) : []\n        allColumns.forEach(columnId => {\n          const column = { name: columnId, values: [], type: DataType.UNKNOWN } as any\n          for (const row of filteredRows) column.values.push(row[columnId])\n          filteredDataTable[columnId] = column\n        })\n      }\n\n      // now redraw colors for fills and liness\n      if (this.currentUIFillColorDefinitions?.dataset) {\n        this.handleNewFillColor(\n          filteredRows ? filteredDataTable : this.currentUIFillColorDefinitions\n        )\n      }\n\n      if (this.currentUILineColorDefinitions?.dataset) {\n        this.handleNewLineColor(\n          filteredRows ? filteredDataTable : this.currentUILineColorDefinitions\n        )\n      }\n    },\n\n    // ------------------------------------\n    // TODO do shapes later\n\n    // // hide shapes that don't match filter.\n    // const hideFeature = new Uint8Array(this.boundaries.length).fill(1) // hide by default\n    // filteredRows.forEach(row => {\n    //   const rowNumber = row['@']\n    //   hideFeature[rowNumber] = 0\n    // })\n    // const newFilter = new Float32Array(this.boundaries.length)\n    // for (let i = 0; i < this.boundaries.length; i++) {\n    //   if (this.boundaryFilters[i] == -1 || hideFeature[i]) newFilter[i] = -1\n    // }\n\n    // this.boundaryFilters = newFilter\n    // return\n\n    // ------------------------------------\n\n    // let groupLookup: any // this will be the map of boundary IDs to rows\n    // let groupIndex: any = 1 // unfiltered values will always be element 1 of [key, values[]]\n\n    // if (!filteredRows) {\n    //   // is filter UN-selected? Rebuild full dataset\n    //   // TODO: FIXME this is old ------:\n    //   // const joinCol = this.boundaryDataTable[this.datasetJoinColumn].values\n    //   // const dataValues = this.boundaryDataTable[this.datasetValuesColumn].values\n    //   // groupLookup = group(zip(joinCol, dataValues), d => d[0]) // group by join key\n    //   filteredRows = [] // get rid of this\n    // } else {\n    //   // group filtered values by lookup key\n    //   groupLookup = group(filteredRows, d => d[join[0]])\n    //   groupIndex = this.datasetValuesColumn // index is values column name\n    // }\n\n    // console.log({ groupLookup })\n\n    // // Build the filtered dataset columns\n    // const filteredDataset: DataTable = {}\n    // const columns = Object.keys(filteredRows[0])\n    // for (const column of columns) {\n    //   filteredDataset[column] = { name: column, values: [], type: DataType.NUMBER }\n    // }\n    // for (let i = 0; i < filteredRows.length; i++) {\n    //   for (const column of columns) {\n    //     filteredDataset[column].values[i] = filteredRows[i][column]\n    //   }\n    // }\n\n    // console.log({ filteredDataset })\n    // // ok we have a filter, let's update the geojson values\n    // this.setupJoin(filteredDataset, '_filter', join[0], join[1])\n\n    // // const filteredBoundaries = [] as any[]\n\n    //       this.boundaries.forEach(boundary => {\n    //         // id can be in root of feature, or in properties\n    //         let lookupKey = boundary.properties[joinShapesBy] || boundary[joinShapesBy]\n    //         if (!lookupKey) this.$emit('error', `Shape is missing property \"${joinShapesBy}\"`)\n\n    //         // the groupy thing doesn't auto-convert between strings and numbers\n    //         let row = groupLookup.get(lookupKey)\n    //         if (row == undefined) row = groupLookup.get('' + lookupKey)\n\n    //         // do we have an answer\n    //         boundary.properties.value = row ? sum(row.map((v: any) => v[groupIndex])) : 'N/A'\n    //         filteredBoundaries.push(boundary)\n    //       })\n\n    // // centroids\n    // const filteredCentroids = [] as any[]\n    // this.centroids.forEach(centroid => {\n    //   const centroidId = centroid.properties!.id\n    //   if (!centroidId) return\n\n    //   let row = groupLookup.get(centroidId)\n    //   if (row == undefined) row = groupLookup.get('' + centroidId)\n    //   centroid.properties!.value = row ? sum(row.map((v: any) => v[groupIndex])) : 'N/A'\n    //   filteredCentroids.push(centroid)\n    // })\n\n    // this.boundaries = filteredBoundaries\n    // this.centroids = filteredCentroids\n    // } catch (e) {\n    //   console.error('' + e)\n    // }\n\n    async loadBoundaries() {\n      let now = Date.now()\n\n      const shapeConfig =\n        this.config.boundaries || this.config.shapes || this.config.geojson || this.config.network\n\n      if (!shapeConfig) return\n\n      // shapes could be a string or an object: shape.file=blah\n      let filename: string = shapeConfig.file || shapeConfig\n\n      let featureProperties = [] as any[]\n      let boundaries: any[]\n\n      try {\n        this.statusText = 'Loading features...'\n\n        if (filename.startsWith('http')) {\n          // geojson from url!\n          boundaries = (await fetch(filename).then(async r => await r.json())).features\n          // this.boundaries = boundaries.features\n        } else if (filename.toLocaleLowerCase().endsWith('.shp')) {\n          // shapefile!\n          boundaries = await this.loadShapefileFeatures(filename)\n          // this.boundaries = boundaries\n        } else {\n          // geojson!\n          boundaries = (await this.fileApi.getFileJson(`${this.subfolder}/${filename}`)).features\n          // this.boundaries = boundaries.features\n        }\n\n        // for a big speedup, move properties to its own nabob\n        let hasNoLines = true\n        let hasNoPolygons = true\n        let hasPoints = false\n\n        boundaries.forEach(b => {\n          const properties = b.properties ?? {}\n          // geojson sometimes has \"id\" outside of properties:\n          if ('id' in b) properties.id = b.id\n          // create a new properties object for each row;\n          // push this new property object to the featureProperties array\n          featureProperties.push({ ...properties })\n          // clear out actual feature properties; they are now in featureProperties instead\n          b.properties = {}\n\n          // points?\n          if (b.geometry.type == 'Point' || b.geometry.type == 'MultiPoint') {\n            hasPoints = true\n          }\n\n          // check if we have linestrings: network mode !\n          if (\n            hasNoLines &&\n            (b.geometry.type == 'LineString' || b.geometry.type == 'MultiLineString')\n          ) {\n            hasNoLines = false\n          }\n\n          // check if we have polygons: area-map mode !\n          if (\n            hasNoPolygons &&\n            (b.geometry.type == 'Polygon' || b.geometry.type == 'MultiPolygon')\n          ) {\n            hasNoPolygons = false\n          }\n        })\n\n        this.moveLogo()\n\n        // set feature properties as a data source\n        await this.setFeaturePropertiesAsDataSource(filename, [...featureProperties], shapeConfig)\n\n        // turn ON line borders if it's a SMALL dataset (user can re-enable)\n        if (!hasNoLines || boundaries.length < 5000) {\n          this.dataLineColors = '#4e79a7'\n        }\n\n        // hide polygon/point buttons and opacity if we have no polygons or we do have points\n        if (hasNoPolygons) this.isAreaMode = false\n        if (hasPoints) this.isAreaMode = true\n\n        this.boundaries = boundaries\n\n        // generate centroids if we have polygons\n        if (!hasNoPolygons || hasPoints) {\n          await this.generateCentroidsAndMapCenter()\n        } else if (this.needsInitialMapExtent) {\n          this.calculateAndMoveToCenter()\n        }\n\n        // Need to wait one tick so Vue inserts the Deck.gl view AFTER center is calculated\n        // (not everyone lives in Berlin)\n        await this.$nextTick()\n\n        // set features INSIDE react component\n        if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n          REACT_VIEW_HANDLES[1000 + this.layerId](this.boundaries)\n        }\n      } catch (e) {\n        const err = e as any\n        const message = err.statusText || 'Could not load'\n        const fullError = `${message}: \"${filename}\"`\n\n        this.statusText = ''\n        this.$emit('isLoaded')\n\n        throw Error(fullError)\n      }\n\n      if (!this.boundaries) throw Error(`No \"features\" found in shapes file`)\n    },\n\n    async setFeaturePropertiesAsDataSource(\n      filename: string,\n      featureProperties: any[],\n      config: any\n    ) {\n      const dataTable = await this.myDataManager.setFeatureProperties(\n        filename,\n        featureProperties,\n        config\n      )\n      this.boundaryDataTable = dataTable\n\n      const datasetId = filename.substring(1 + filename.lastIndexOf('/'))\n      this.datasets[datasetId] = dataTable\n\n      this.vizDetails.datasets[datasetId] = {\n        file: datasetId,\n        join: this.datasetJoinColumn,\n      } as any\n\n      this.config.datasets = Object.assign({}, this.vizDetails.datasets)\n      // console.log(333, this.vizDetails)\n\n      // this.myDataManager.addFilterListener({ dataset: datasetId }, this.filterListener)\n      // this.figureOutRemainingFilteringOptions()\n    },\n\n    async calculateAndMoveToCenter() {\n      let centerLong = 0\n      let centerLat = 0\n      let numCoords = 0\n      const numFeatures = this.boundaries.length\n\n      for (let idx = 0; idx < numFeatures; idx += 256) {\n        const centroid = turf.centerOfMass(this.boundaries[idx])\n        if (centroid?.geometry?.coordinates) {\n          centerLong += centroid.geometry.coordinates[0]\n          centerLat += centroid.geometry.coordinates[1]\n          numCoords += 1\n        }\n      }\n\n      centerLong /= numCoords\n      centerLat /= numCoords\n\n      console.log('CENTER', centerLong, centerLat)\n      if (this.needsInitialMapExtent && !this.vizDetails.center) {\n        this.$store.commit('setMapCamera', {\n          longitude: centerLong,\n          latitude: centerLat,\n          center: [centerLong, centerLat],\n          bearing: 0,\n          pitch: 0,\n          zoom: 9,\n          initial: true,\n        })\n        this.needsInitialMapExtent = false\n      }\n    },\n\n    async generateCentroidsAndMapCenter() {\n      this.statusText = 'Calculating centroids...'\n      await this.$nextTick()\n      const idField = this.config.shapes.join || 'id'\n\n      // Find the map center while we're here\n      let centerLong = 0\n      let centerLat = 0\n      let count = 0\n\n      for (const feature of this.boundaries) {\n        let centroid = {} as any\n        try {\n          centroid = turf.centerOfMass(feature as any)\n        } catch (e) {\n          console.warn('no coordinates:')\n          console.warn(feature)\n          continue\n        }\n\n        if (!centroid.properties) centroid.properties = {}\n\n        if (feature.properties[this.config.boundariesLabel]) {\n          centroid.properties.label = feature.properties[this.config.boundariesLabel]\n        }\n\n        centroid.properties.id = feature.properties[idField]\n        if (centroid.properties.id === undefined) centroid.properties.id = feature[idField]\n\n        this.centroids.push(centroid)\n\n        if (centroid.geometry) {\n          centerLong += centroid.geometry.coordinates[0]\n          centerLat += centroid.geometry.coordinates[1]\n          count++\n        }\n      }\n\n      centerLong /= count\n      centerLat /= count\n\n      console.log('CENTER', centerLong, centerLat)\n      if (this.needsInitialMapExtent && !this.vizDetails.center) {\n        this.$store.commit('setMapCamera', {\n          longitude: centerLong,\n          latitude: centerLat,\n          center: [centerLong, centerLat],\n          bearing: 0,\n          pitch: 0,\n          zoom: 9,\n          initial: true,\n        })\n        this.needsInitialMapExtent = false\n      }\n    },\n\n    async loadShapefileFeatures(filename: string) {\n      this.statusText = 'Loading shapefile...'\n      console.log('loading', filename)\n\n      const url = `${this.subfolder}/${filename}`\n\n      // first, get shp/dbf files\n      let geojson: any = {}\n      try {\n        const shpPromise = this.fileApi.getFileBlob(url)\n        const dbfFilename = url\n          .replace('.shp', '.dbf')\n          .replace('.SHP', '.DBF')\n          .replace('.Shp', '.Dbf')\n        const dbfPromise = this.fileApi.getFileBlob(dbfFilename)\n        await Promise.all([shpPromise, dbfPromise])\n\n        const shpBlob = await (await shpPromise)?.arrayBuffer()\n        const dbfBlob = await (await dbfPromise)?.arrayBuffer()\n        if (!shpBlob || !dbfBlob) return []\n\n        this.statusText = 'Generating shapes...'\n\n        geojson = await shapefile.read(shpBlob, dbfBlob)\n\n        // filter out features that don't have geometry: they can't be mapped\n        geojson.features = geojson.features.filter((f: any) => !!f.geometry)\n      } catch (e) {\n        console.error(e)\n        this.$emit('error', '' + e)\n        return []\n      }\n\n      // geojson.features = geojson.features.slice(0, 10000)\n\n      // See if there is a .prj file with projection information\n      let projection = DEFAULT_PROJECTION\n      const prjFilename = url\n        .replace('.shp', '.prj')\n        .replace('.SHP', '.PRJ')\n        .replace('.Shp', '.Prj')\n      try {\n        projection = await this.fileApi.getFileText(prjFilename)\n      } catch (e) {\n        // lol we can live without a projection right? ;-O\n      }\n\n      // Allow user to override .PRJ projection with YAML config\n      const guessCRS = this.vizDetails.projection || Coords.guessProjection(projection)\n\n      console.log({ guessCRS })\n      // then, reproject if we have a .prj file\n      if (guessCRS) {\n        this.statusText = 'Projecting coordinates...'\n        await this.$nextTick()\n        geojson = reproject.toWgs84(geojson, guessCRS, Coords.allEPSGs)\n        this.statusText = ''\n      }\n\n      function getFirstPoint(thing: any): any[] {\n        if (Array.isArray(thing[0])) return getFirstPoint(thing[0])\n        else return [thing[0], thing[1]]\n      }\n\n      // check if we have lon/lat\n      const firstPoint = getFirstPoint(geojson.features[0].geometry.coordinates)\n      if (Math.abs(firstPoint[0]) > 180 || Math.abs(firstPoint[1]) > 90) {\n        // this ain't lon/lat\n        const msg = `Coordinates not lon/lat. Try providing ${prjFilename.substring(\n          1 + prjFilename.lastIndexOf('/')\n        )}`\n        this.$emit('error', msg)\n        this.statusText = msg\n        return []\n      }\n\n      // if (this.needsInitialMapExtent && !this.$store.state.viewState.latitude) {\n      if (true) {\n        // if we don't have a user-specified map center/zoom, focus on the shapefile itself\n\n        const long = []\n        const lat = []\n        for (let i = 0; i < geojson.features.length; i += 128) {\n          const firstPoint = getFirstPoint(geojson.features[i].geometry.coordinates)\n          long.push(firstPoint[0])\n          lat.push(firstPoint[1])\n        }\n        const longitude = long.reduce((x, y) => x + y) / long.length\n        const latitude = lat.reduce((x, y) => x + y) / lat.length\n\n        this.$store.commit('setMapCamera', {\n          longitude,\n          latitude,\n          bearing: 0,\n          pitch: 0,\n          zoom: 9,\n          center: [longitude, latitude],\n          initial: true,\n        })\n      }\n\n      this.needsInitialMapExtent = false\n      return geojson.features as any[]\n    },\n\n    async loadDatasets() {\n      const keys = Object.keys(this.vizDetails.datasets)\n      for (const key of keys) {\n        // don't reload datasets we already loaded\n        if (key in this.datasets) continue\n\n        await this.loadDataset(key)\n      }\n    },\n\n    async loadDataset(datasetKey: string) {\n      try {\n        if (!datasetKey) return\n\n        // dataset could be  { dataset: myfile.csv }\n        //               or  { dataset: { file: myfile.csv, join: TAZ }}\n        const datasetFilename =\n          'string' === typeof this.config.datasets[datasetKey]\n            ? this.config.datasets[datasetKey]\n            : this.config.datasets[datasetKey].file\n\n        this.statusText = `Loading dataset ${datasetFilename} ...`\n\n        await this.$nextTick()\n\n        let loaderConfig = { dataset: datasetFilename }\n        if ('string' !== typeof this.config.datasets[datasetKey]) {\n          loaderConfig = Object.assign(loaderConfig, this.config.datasets[datasetKey])\n        }\n\n        // save the filename and key for later lookups\n        this.datasetKeyToFilename[datasetKey] = datasetFilename\n\n        const dataset = await this.myDataManager.getDataset(loaderConfig)\n\n        // figure out join - use \".join\" or first column key\n        const joiner =\n          'string' === typeof this.config.datasets[datasetKey]\n            ? Object.keys(dataset.allRows)[0]\n            : this.config.datasets[datasetKey].join\n\n        const joinColumns = joiner?.split(':') || []\n\n        // if join is oldstyle \"dataCol:FeatureID\" the set the featureCol\n        if (joinColumns.length == 2) this.featureJoinColumn = joinColumns[0]\n        // TODO if join is one column then really we should just ignore it but for now...\n        if (joinColumns.length == 1) joinColumns.push(joinColumns[0])\n\n        // save it!\n        this.datasets[datasetKey] = dataset.allRows\n\n        await this.$nextTick()\n\n        // Set up filters -- there could be some in YAML already\n        this.myDataManager.addFilterListener({ dataset: datasetFilename }, this.processFiltersNow)\n        this.activateFiltersForDataset(datasetKey)\n      } catch (e) {\n        const msg = '' + e\n        console.error(msg)\n        this.$emit('error', msg)\n      }\n      return []\n    },\n\n    activateFiltersForDataset(datasetKey: string) {\n      const filters = this.filterDefinitions.filter(f => f.dataset === datasetKey)\n\n      for (const filter of filters) {\n        console.log(3, JSON.stringify(filter))\n        // if user selected a @categorical, just add it to the thingy\n        if (filter.value == '@categorical') {\n          if (this.filters[filter.column]) {\n            filter.value = this.filters[filter.column].active\n          } else {\n            this.handleUserCreatedNewFilter(`${datasetKey}:${filter.column}`)\n          }\n        } else {\n          // actually filter the data\n          this.myDataManager.setFilter(\n            Object.assign(filter, { dataset: this.datasetKeyToFilename[datasetKey] })\n          )\n        }\n      }\n    },\n\n    filterLabel(filter: string) {\n      let label = this.filters[filter].active.join(',').substring(0, 50) || 'Select...'\n      if (label.length === 50) label += '...'\n      return label\n    },\n\n    async handleUserSelectedNewMetric() {\n      // console.log('> handleUserSelectedNewMetric')\n      await this.$nextTick()\n      console.log('METRIC', this.datasetValuesColumn)\n\n      const query = Object.assign({}, this.$route.query)\n      query.display = this.datasetValuesColumn\n      this.$router.replace({ query })\n\n      this.maxValue = this.boundaryDataTable[this.datasetValuesColumn].max || 0\n      console.log('MAXVALUE', this.maxValue)\n\n      this.vizDetails.display.fill.columnName = this.datasetValuesColumn\n      this.vizDetails = Object.assign({}, this.vizDetails)\n      this.processFiltersNow()\n    },\n\n    handleUserSelectedNewFilters(column: string) {\n      const filter = this.filters[column]\n      const active = filter.active\n\n      this.myDataManager.setFilter({\n        dataset: this.datasetKeyToFilename[filter.dataset], // || datasetFilename,\n        column,\n        invert: false,\n        value: active, // '', // <-- what should this be?\n      })\n\n      // update URL too\n      const queryFilters = Object.assign({}, this.$route.query)\n      for (const filter of Object.entries(this.filters)) {\n        if (filter[1].active.length) {\n          queryFilters[filter[0]] = filter[1].active.join(',')\n        } else {\n          delete queryFilters[filter[0]]\n        }\n      }\n      // only update if query actually changed\n      if (JSON.stringify(this.$route.query) !== JSON.stringify(queryFilters)) {\n        this.$router.replace({ query: queryFilters })\n      }\n    },\n\n    showCircles(show: boolean) {\n      this.useCircles = show\n\n      const query = Object.assign({}, this.$route.query)\n      if (show) query.show = 'dots'\n      else delete query.show\n      this.$router.replace({ query })\n    },\n\n    handleUserCreatedNewFilter(selectedColumn?: string) {\n      const selection = selectedColumn || this.chosenNewFilterColumn\n      const [dataset, column] = selection.split(':')\n\n      let options = [...new Set(this.datasets[dataset][column].values)]\n      this.chosenNewFilterColumn = ''\n\n      if (options.length > 48) {\n        alert(`Column ${column} has too many values to be used as a filter.`)\n        return\n      }\n      this.filters[column] = { column, label: column, options, active: [], dataset }\n    },\n\n    updateChart() {\n      // boundaryDataTable come back as an object of columnName: values[].\n      // We need to make a lookup of the values by ID, and then\n      // insert those values into the boundaries geojson.\n\n      // console.log(this.config)\n      // console.log(this.datasets)\n      if (!this.config.display || !this.config.datasets) return\n\n      let joinShapesBy = 'id'\n\n      if (this.config.shapes?.join) joinShapesBy = this.config.shapes.join\n      // throw Error('Need \"join\" property to link shapes to datasets')\n\n      const datasetJoinCol = this.datasetJoinColumn // used to be this.config.display.fill.join\n      if (!datasetJoinCol) {\n        console.error(`No join column ${datasetJoinCol}`)\n        return\n      }\n\n      // value columns should be an array but might not be there yet\n      let valueColumns = this.config.display.fill.values\n      if (!valueColumns) {\n        this.statusText = ''\n        throw Error(`Need to specify column for data values`)\n      }\n\n      // Display values from query param if available, or config, or first option.\n      if (this.$route.query.display) this.config.display.fill.columnName = this.$route.query.display\n      let datasetValuesCol = this.config.display.fill.columnName || valueColumns[0]\n\n      this.datasetValuesColumn = datasetValuesCol\n      // this.datasetValuesColumnOptions = valueColumns\n\n      // this.setupFilters()\n\n      // 1. build the data lookup for each key in the dataset.\n      //    There is often more than one row per key, so we will\n      //    create an array for the group now, and (sum) them in step 2 below\n      const joinCol = this.boundaryDataTable[datasetJoinCol].values\n      const dataValues = this.boundaryDataTable[datasetValuesCol].values\n      const groupLookup = group(zip(joinCol, dataValues), d => d[0]) // group by join key\n\n      let max = 0\n\n      // 2. insert values into geojson\n      for (let idx = 0; idx < this.boundaries.length; idx++) {\n        const boundary = this.boundaries[idx]\n        const centroid = this.centroids[idx]\n\n        // id can be in root of feature, or in properties\n        let lookupValue = boundary[joinShapesBy]\n        if (lookupValue == undefined) lookupValue = boundary.properties[joinShapesBy]\n\n        if (lookupValue === undefined) {\n          this.$emit('error', `Shape is missing property \"${joinShapesBy}\"`)\n        }\n\n        // SUM the values of the second elements of the zips from (1) above\n        const row = groupLookup.get(lookupValue)\n        if (row) {\n          boundary.properties.value = sum(row.map(v => v[1]))\n          max = Math.max(max, boundary.properties.value)\n        } else {\n          boundary.properties.value = 'N/A'\n        }\n\n        // update the centroid too\n        if (centroid) centroid.properties!.value = boundary.properties.value\n      }\n\n      // this.maxValue = max // this.boundaryDataTable[datasetValuesCol].max || 0\n      this.maxValue = this.boundaryDataTable[datasetValuesCol].max || 0\n\n      // // 3. insert values into centroids\n      // this.centroids.forEach(centroid => {\n      //   const centroidId = centroid.properties!.id\n      //   if (!centroidId) return\n\n      //   let row = groupLookup.get(centroidId)\n      //   if (row === undefined) row = groupLookup.get(parseInt(centroidId))\n      //   centroid.properties!.value = row ? sum(row.map(v => v[1])) : 'N/A'\n      // })\n\n      // sort them so big bubbles are below small bubbles\n      this.centroids = this.centroids.sort((a: any, b: any) =>\n        a.properties.value > b.properties.value ? -1 : 1\n      )\n      this.activeColumn = 'value'\n    },\n\n    clearData() {\n      // these lines change the properties of these objects\n      // WITHOUT reassigning them to new objects; this is\n      // essential for the garbage-collection to work properly.\n      // Otherwise we get a 500Mb memory leak on every view :-D\n      this.boundaries = []\n      this.centroids = []\n      this.boundaryDataTable = {}\n      this.boundaryFilters = new Float32Array(0)\n      this.datasets = {}\n      this.dataFillColors = '#888'\n      this.dataLineColors = ''\n      this.dataLineWidths = 1\n      this.dataPointRadii = 5\n      this.dataFillHeights = 0\n      this.dataCalculatedValues = null\n      this.dataCalculatedValueLabel = ''\n    },\n  },\n\n  async mounted() {\n    try {\n      // EMBED MODE?\n      this.setEmbeddedMode()\n\n      this.clearData()\n      await this.getVizDetails()\n      if (this.vizDetails.center && typeof this.vizDetails.center === 'string') {\n        this.vizDetails.center = this.vizDetails.center\n          //@ts-ignore\n          .split(',')\n          .map((coord: any) => parseFloat(coord))\n        this.config.center = this.config.center.split(',').map((coord: any) => parseFloat(coord))\n      }\n\n      this.buildThumbnail()\n      if (this.thumbnail) return\n\n      this.buildOldJoinLookups()\n\n      this.filterDefinitions = this.parseFilterDefinitions(this.vizDetails.filters)\n\n      this.setupLogoMover()\n\n      if (this.needsInitialMapExtent && this.vizDetails.center) {\n        this.$store.commit('setMapCamera', {\n          center: this.vizDetails.center,\n          zoom: this.vizDetails.zoom || 9,\n          bearing: this.vizDetails.bearing || 0,\n          pitch: this.vizDetails.pitch || 0,\n          longitude: this.vizDetails.center ? this.vizDetails.center[0] : 0,\n          latitude: this.vizDetails.center ? this.vizDetails.center[1] : 0,\n          initial: true,\n        })\n        this.needsInitialMapExtent = false\n      }\n\n      this.expColors = this.config.display?.fill?.exponentColors\n      this.dataFillColors = globalStore.state.isDarkMode ? '#44445580' : '#dddddd80'\n\n      // convert values to arrays as needed\n      if (!this.config.display.fill) this.config.display.fill = {}\n\n      if (this.config.display?.fill?.values) {\n        this.config.display.fill.values = this.convertCommasToArray(this.config.display.fill.values)\n      }\n\n      // load the boundaries first, then the dataset.\n      // Need boundaries first so we can build the lookups!\n      await this.loadBoundaries()\n      this.filterShapesNow()\n\n      this.isLoaded = true\n      this.$emit('isLoaded')\n\n      await this.loadDatasets()\n\n      // Check URL query parameters\n\n      this.datasets = Object.assign({}, this.datasets)\n      this.config.datasets = JSON.parse(JSON.stringify(this.datasets))\n      this.vizDetails = Object.assign({}, this.vizDetails)\n\n      this.honorQueryParameters()\n\n      this.statusText = ''\n\n      // Ask for shapes feature ID if it's not obvious/specified already\n      this.featureJoinColumn = await this.figureOutFeatureIdColumn()\n    } catch (e) {\n      this.$emit('error', '' + e)\n      this.statusText = ''\n      this.$emit('isLoaded')\n    }\n  },\n\n  beforeDestroy() {\n    // MUST delete the React view handles to prevent gigantic memory leaks!\n    delete REACT_VIEW_HANDLES[this.layerId]\n\n    if (REACT_VIEW_HANDLES[1000 + this.layerId]) {\n      REACT_VIEW_HANDLES[1000 + this.layerId]([])\n      delete REACT_VIEW_HANDLES[1000 + this.layerId]\n    }\n\n    this.clearData()\n    this.legendStore.clear()\n    this.resizer?.disconnect()\n\n    this.myDataManager.removeFilterListener(this.config, this.processFiltersNow)\n    // this.myDataManager.clearCache()\n    this.$store.commit('setFullScreen', false)\n  },\n})\n\nexport default MyComponent\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.map-layout {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  min-height: $thumbnailHeight;\n  background: url('assets/thumbnail.jpg') no-repeat;\n  background-size: cover;\n  z-index: -1;\n}\n\n.map-layout.hide-thumbnail {\n  background: unset;\n  z-index: 0;\n}\n\n.area-map {\n  position: relative;\n  flex: 1;\n  background-color: var(--bgBold);\n}\n\n.config-bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: flex;\n  flex-direction: row;\n  margin: 0.5rem;\n  padding: 0.25rem 0rem 0.5rem 0.5rem;\n  background-color: var(--bgPanel);\n  z-index: 9;\n  opacity: 0.93;\n  input.slider {\n    margin: auto 0 0.5rem auto;\n    width: 8rem;\n  }\n\n  .map-type-buttons {\n    margin: auto 0 0 0.5rem;\n  }\n\n  .img-button {\n    margin: 0 0rem -5px 0.5rem;\n    height: 2.3rem;\n    width: 2.3rem;\n    border: var(--borderThin);\n    border-radius: 4px;\n  }\n  .img-button:hover {\n    border: 2px solid var(--linkHover);\n  }\n}\n\n.config-bar.is-disabled {\n  pointer-events: none;\n  opacity: 0.5;\n}\n\n.filter {\n  margin-right: 0.5rem;\n  display: flex;\n  flex-direction: column;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.filter p {\n  margin: -0.25rem 0 0 0;\n  font-weight: bold;\n}\n\n.title-panel {\n  position: absolute;\n  top: 0;\n  left: 0;\n  padding: 0 1rem 0.25rem 2rem;\n  background-color: var(--bgPanel);\n  filter: $filterShadow;\n  z-index: 2;\n}\n\n.status-bar {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  z-index: 200;\n  background-color: var(--bgPanel2);\n  padding: 1rem 1rem;\n  font-size: 1.1rem;\n  margin-bottom: 6px;\n  border: 1px solid var(--);\n}\n\n.right {\n  margin-left: auto;\n}\n\n.details-panel {\n  text-align: left;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  background-color: var(--bgPanel);\n  display: flex;\n  filter: $filterShadow;\n  flex-direction: row;\n  margin: 0.5rem;\n  padding: 0.25rem 0.5rem;\n  // width: 15rem;\n  font-size: 0.8rem;\n  color: var(--bold);\n  opacity: 0.95;\n  max-height: 75%;\n  overflow-x: hidden;\n  overflow-y: auto;\n  white-space: nowrap;\n}\n\n@media only screen and (max-width: 640px) {\n}\n</style>\n"],"names":["proj4","require$$0","isXY","list","traverseCoords","coordinates","callback","coord","clone","obj","copy","attr","traverseGeoJson","geometryCb","nodeCb","geojson","r","self","detectCrs","projs","crsInfo","crs","determineCrs","calcBbox","min","max","_gj","xy","reproject","from","to","transformFunc","transform","coords","transformed","transformGeometryCoords","gj","transformBbox","reproject_1","isHighSurrogate","codePoint","isLowSurrogate","truncate","getLength","string","byteLength","charLength","curByteLength","segment","i","browser","prevCodePoint","require$$1","illegalRe","controlRe","reservedRe","windowsReservedRe","windowsTrailingRe","sanitize","input","replacement","sanitized","sanitizeFilename","options","output","forwardProps","layer","mapping","transitions","updateTriggers","result","sourceKey","targetKey","value","OFFSET_TYPE","LINE_LAYER","PathOffsetLayer","GeojsonOffsetLayer","GeoJsonLayer","props","extruded","stroked","layerProps","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","LineStringsLayer","forwardedProps","savePNG","backgroundCanvas","deckLayerImage","backgroundImage","layerData","mergedImage","mergeImageURIs","element","resolve","reject","canvas","dataURL","add2canvas","ctx","boxLeft","boxTop","image","screenshots","Component","viewId","fillColors","lineColors","lineWidths","fillHeights","calculatedValues","calculatedValueLabel","normalizedValues","opacity","pointRadii","screenshot","featureDataTable","featureFilter","tooltip","cbTooltip","features","setFeatures","useState","viewState","setViewState","globalStore","screenshotCount","setScreenshot","_mapRef","useRef","REACT_VIEW_HANDLES","fullCopy","feature","f","isTakingScreenshot","cbFillColor","color","rgb","o","isStroked","cbLineColor","_","cbLineWidth","cbPointRadius","cbFillHeight","handleViewState","view","handleClick","truncateFractionalPart","precision","printValue","getTooltip","object","index","_a","propList","label","cLabel","datasetProps","featureTips","tipKey","tipValue","columns","tip","featureProps","column","html","OFFSET_DIRECTION","DataFilterExtension","deckInstance","React","DeckGL","e","isDragging","isHovering","StaticMap","MAPBOX_TOKEN","defineComponent","viz","mapCamera","styles","maplibregl","baubles","elem","bearing","longitude","latitude","zoom","pitch","ColorScheme","i18n","ID_GUESSES","_sfc_main","guess","found","MyComponent","BackgroundMapOnTop","GeojsonLayer","ModalIdColumnPicker","VizConfigurator","ZoomButtons","DrawingTool","LegendStore","DashboardDataManager","HTTPFileSystem","svnProject","a","filename","Sanitize","p","tooltips","deckmap","logo","right","datasetId","data","shapeFilters","isLTGT","filter","spec","conditional","v","numericString","fullSpecification","dataColumnValues","checkFilterValue","actualValue","includeElement","filterValue","filterDefs","filters","filterSpecs","id","dataset","filterDefinition","datasetKeys","firstDatasetKey","firstDataset","columnNames","queryFilters","text","thing","emptyState","ycfg","title","oldJoinFieldPerDataset","join","colon","shapeJoinField","section","details","blob","buffer","readBlob","base64","arrayBufferToBase64","name","config","YAML","err","message","vizes","key","dataTable","datasetFilename","dataJoinColumn","lookupColumn","DataType","lookupValues","boundaryOffsets","relevantTips","Status","featureOffset","joinColumn","boundaryLookupColumnValues","oldFilters","deletedFilter","dot","query","newDefinitions","datasetKey","columnName","key1","dataset1","key2","dataset2","relative","lookup1","lookup2","dataCol1","dataCol2","normalColumn","normalLookup","array","legend","ColorWidthSymbologizer","currentDefinition","keys","fillOrFilteredDataTable","isFillColorDefinition","isFilterTable","filteredRows","selectedDataset","dataColumn","colorOrFilteredDataTable","isColorDefinition","colors","hasCategory","lineWidth","variableConstantWidth","width","height","heights","angledView","radiusOptions","radius","click","x","y","featureDataset","availableColumns","boundaryProperties","datasetName","filteredDataTable","columnId","row","_b","shapeConfig","featureProperties","boundaries","hasNoLines","hasNoPolygons","hasPoints","b","properties","fullError","centerLong","centerLat","numCoords","numFeatures","idx","centroid","turf.centerOfMass","idField","count","url","shpPromise","dbfFilename","dbfPromise","shpBlob","dbfBlob","shapefile.read","projection","DEFAULT_PROJECTION","prjFilename","guessCRS","Coords","getFirstPoint","firstPoint","msg","long","lat","loaderConfig","joiner","joinColumns","active","show","selectedColumn","selection","joinShapesBy","datasetJoinCol","valueColumns","datasetValuesCol","joinCol","dataValues","groupLookup","group","zip","d","boundary","lookupValue","sum","_d","_c"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}