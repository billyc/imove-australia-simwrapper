{"version":3,"file":"icon-manager-188a634e.js","sources":["../../src/layers/moving-icons/icon-layer.glsl.vert?raw","../../src/layers/moving-icons/icon-layer.glsl.frag?raw","../../src/layers/moving-icons/icon-manager.ts"],"sourcesContent":["export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\n//\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME icon-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute float instanceSizes;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec4 instanceIconFrames;\\nattribute float instanceColorModes;\\nattribute vec2 instanceOffsets;\\nattribute vec2 instancePixelOffset;\\n\\nuniform float sizeScale;\\nuniform vec2 iconsTextureDim;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform bool billboard;\\n\\nuniform float currentTime;\\n\\nuniform vec2 iconStillOffsets;\\nuniform vec4 iconStillFrames;\\n\\nattribute float instanceTimestamps;\\nattribute float instanceTimestampsNext;\\nattribute vec2 instanceStartPositions;\\nattribute vec2 instanceEndPositions;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\nvarying float vPercentComplete;\\n\\n// ------------------------------------------------------------------\\n\\nvec2 rotate_by_angle(vec2 vertex, float angle_radian) {\\n  float cos_angle = cos(angle_radian);\\n  float sin_angle = sin(angle_radian);\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\n  return rotationMatrix * vertex;\\n}\\n\\nvec3 interpolate(in vec3 point1, in vec3 point2, in float timestepFraction) {\\n    if (timestepFraction <= 0.0) {\\n        return point1;\\n    } else if (timestepFraction >= 1.0 ) {\\n        return point2;\\n    } else {\\n        vec3 direction = point2 - point1;\\n        return point1 + (direction * timestepFraction);\\n    }\\n}\\n\\nvoid main(void) {\\n\\n  // Calculate progress:\\n  // Skip everything else if this vertex is outside the time window\\n  if (currentTime < instanceTimestamps) {\\n    vPercentComplete = -1.0;\\n    return;\\n  } else if (currentTime > instanceTimestampsNext) {\\n    vPercentComplete = -1.0;\\n    return;\\n  } else {\\n    vPercentComplete = (currentTime - instanceTimestamps) /\\n                       (instanceTimestampsNext - instanceTimestamps);\\n  }\\n\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vec3 startPosition = vec3(instanceStartPositions, 5.0);\\n  vec3 endPosition = vec3(instanceEndPositions, 5.0);\\n\\n  // are we stationary/still\\n  bool still = (instanceStartPositions == instanceEndPositions);\\n\\n  // geometry.uv = positions;\\n  // uv = positions;\\n\\n  // this could be the problem right here;\\n  vec2 iconSize = still ? iconStillFrames.zw : instanceIconFrames.zw;\\n  // convert size in meters to pixels, then scaled and clamp\\n  // project meters to pixels and clamp to limits\\n  float sizePixels = clamp(\\n    project_size_to_pixel(instanceSizes * sizeScale),\\n    sizeMinPixels, sizeMaxPixels\\n  );\\n\\n  // scale icon height to match instanceSize\\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\\n\\n  // // figure out angle based on motion direction\\n  float angle = 0.0;\\n  if (!still) {\\n    vec3 direction = normalize(endPosition - startPosition);\\n    angle = atan( direction.y / direction.x);\\n    if (direction.x < 0.0) angle = angle - PI;\\n  }\\n\\n  // scale and rotate vertex in \\\"pixel\\\" value and convert back to fraction in clipspace\\n  vec2 pixelOffset = positions / 2.0 * iconSize + (still ? iconStillOffsets : instanceOffsets);\\n  pixelOffset = rotate_by_angle(pixelOffset, angle) * instanceScale;\\n  pixelOffset += instancePixelOffset;\\n  pixelOffset.y *= -1.0;\\n\\n  vec3 newPosition = interpolate(startPosition, endPosition, vPercentComplete);\\n\\n  if (billboard)  {\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), vec3(0.0), geometry.position);\\n    vec3 offset = vec3(pixelOffset, 0.0);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n\\n  } else {\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), offset_common, geometry.position);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  vec2 upperleft = (still ? iconStillFrames.xy : instanceIconFrames.xy);\\n\\n  vTextureCoords = mix(\\n    upperleft,\\n    upperleft + iconSize,\\n    (positions.xy + 1.0) / 2.0\\n  ) / iconsTextureDim;\\n\\n  vColor = instanceColors;\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n\\n  vColorMode = instanceColorModes;\\n}\\n\"","export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\n//\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME icon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float opacity;\\nuniform sampler2D iconsTexture;\\nuniform float alphaCutoff;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nuniform float currentTime;\\nvarying float vPercentComplete;\\n\\nvoid main(void) {\\n\\n  if (vPercentComplete == -1.0) discard;\\n\\n  geometry.uv = uv;\\n\\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\\n\\n  // if colorMode == 0, use pixel color from the texture\\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\\n  // Take the global opacity and the alpha from vColor into account for the alpha component\\n  float a = texColor.a * opacity * vColor.a;\\n\\n  if (a < alphaCutoff) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vec4(color, a);\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\"","// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\n//\n/* global document */\nimport GL from '@luma.gl/constants'\nimport { Texture2D, copyToTexture, cloneTextureFrom } from '@luma.gl/core'\nimport { ImageLoader } from '@loaders.gl/images'\nimport { load } from '@loaders.gl/core'\nimport { createIterable } from '@deck.gl/core'\n\nconst DEFAULT_CANVAS_WIDTH = 1024\nconst DEFAULT_BUFFER = 4\n\nconst noop = () => {}\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n}\n\nfunction nextPowOfTwo(number: number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)))\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(ctx: any, imageData: any, width: any, height: any) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData\n  }\n\n  ctx.canvas.height = height\n  ctx.canvas.width = width\n\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height)\n\n  return ctx.canvas\n}\n\nfunction getIconId(icon: any) {\n  return icon && (icon.id || icon.url)\n}\n\n// resize texture without losing original data\nfunction resizeTexture(gl: any, texture: any, width: any, height: any) {\n  const oldWidth = texture.width\n  const oldHeight = texture.height\n\n  const newTexture = cloneTextureFrom(texture, { width, height })\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight,\n  })\n\n  texture.delete()\n  return newTexture\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(mapping: any, columns: any, yOffset: any) {\n  for (let i = 0; i < columns.length; i++) {\n    const { icon, xOffset } = columns[i]\n    const id = getIconId(icon)\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset,\n    }\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n * @param icons {Array<Object>} list of icons, each icon requires url, width, height\n * @param buffer {Number} add buffer to the right and bottom side of the image\n * @param xOffset {Number} right position of last icon in old mapping\n * @param yOffset {Number} top position in last icon in old mapping\n * @param rowHeight {Number} rowHeight of the last icon's row\n * @param canvasWidth {Number} max width of canvas\n * @param mapping {object} old mapping\n * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth,\n}: any) {\n  let columns = []\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i]\n    const id = getIconId(icon)\n\n    if (!mapping[id]) {\n      const { height, width } = icon\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset)\n\n        xOffset = 0\n        yOffset = rowHeight + yOffset + buffer\n        rowHeight = 0\n        columns = []\n      }\n\n      columns.push({\n        icon,\n        xOffset,\n      })\n\n      xOffset = xOffset + width + buffer\n      rowHeight = Math.max(rowHeight, height)\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset)\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer),\n  }\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(data: any, getIcon: any, cachedIcons: any) {\n  if (!data || !getIcon) {\n    return null\n  }\n\n  cachedIcons = cachedIcons || {}\n  const icons = {} as any\n  const { iterable, objectInfo } = createIterable(data)\n  for (const object of iterable) {\n    objectInfo.index++\n    const icon = getIcon(object, objectInfo)\n    const id = getIconId(icon)\n\n    if (!icon) {\n      throw new Error('Icon is missing.')\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.')\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index }\n    }\n  }\n  return icons\n}\n\nexport default class IconManager {\n  gl: any\n  onUpdate: () => void\n  onError: (e: any) => any\n  _loadOptions: any\n  _getIcon: any\n  _texture: any\n  _externalTexture: any\n  _mapping: any\n  _pendingCount: number\n  _autoPacking: boolean\n  _xOffset: number\n  _yOffset: number\n  _rowHeight: number\n  _buffer: number\n  _canvasWidth: number\n  _canvasHeight: number\n  _canvas: any\n\n  constructor(\n    gl: any,\n    {\n      onUpdate = noop, // notify IconLayer when icon texture update\n      onError = noop,\n    }\n  ) {\n    this.gl = gl\n    this.onUpdate = onUpdate\n    this.onError = onError\n\n    // load options used for loading images\n    this._loadOptions = null\n    this._getIcon = null\n\n    this._texture = null\n    this._externalTexture = null\n    this._mapping = {}\n    // count of pending requests to fetch icons\n    this._pendingCount = 0\n\n    this._autoPacking = false\n\n    // internal props used when autoPacking applied\n    // right position of last icon\n    this._xOffset = 0\n    // top position of last icon\n    this._yOffset = 0\n    this._rowHeight = 0\n    this._buffer = DEFAULT_BUFFER\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH\n    this._canvasHeight = 0\n    this._canvas = null\n  }\n\n  finalize() {\n    this._texture?.delete()\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture\n  }\n\n  getIconMapping(icon: any) {\n    const id = this._autoPacking ? getIconId(icon) : icon\n    return this._mapping[id] || {}\n  }\n\n  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, data, getIcon }: any) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking\n    }\n\n    if (getIcon) {\n      this._getIcon = getIcon\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping\n    }\n\n    if (iconAtlas) {\n      this._updateIconAtlas(iconAtlas)\n    }\n\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n      this._canvas = this._canvas || document.createElement('canvas')\n\n      this._updateAutoPacking(data)\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0\n  }\n\n  _updateIconAtlas(iconAtlas: any) {\n    this._texture?.delete()\n    this._texture = null\n    this._externalTexture = iconAtlas\n    this.onUpdate()\n  }\n\n  _updateAutoPacking(data: any) {\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {})\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset,\n      })\n\n      this._rowHeight = rowHeight\n      this._mapping = mapping\n      this._xOffset = xOffset\n      this._yOffset = yOffset\n      this._canvasHeight = canvasHeight\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: DEFAULT_TEXTURE_PARAMETERS,\n        })\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight)\n      }\n\n      this.onUpdate()\n\n      // load images\n      this._loadIcons(icons)\n    }\n  }\n\n  _loadIcons(icons: any) {\n    const ctx = this._canvas.getContext('2d')\n\n    for (const icon of icons) {\n      this._pendingCount++\n      load(icon.url, ImageLoader, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon)\n          const { x, y, width, height } = this._mapping[id]\n\n          const data = resizeImage(ctx, imageData, width, height)\n\n          this._texture.setSubImageData({\n            data,\n            x,\n            y,\n            width,\n            height,\n          })\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          this._texture.generateMipmap()\n\n          this.onUpdate()\n        })\n        .catch(error => {\n          this.onError({\n            url: icon.url,\n            source: icon.source,\n            sourceIndex: icon.sourceIndex,\n            loadOptions: this._loadOptions,\n            error,\n          })\n        })\n        .finally(() => {\n          this._pendingCount--\n        })\n    }\n  }\n}\n"],"names":["vertShader","fragShader","DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_TEXTURE_PARAMETERS","GL","nextPowOfTwo","number","resizeImage","ctx","imageData","width","height","getIconId","icon","resizeTexture","gl","texture","oldWidth","oldHeight","newTexture","cloneTextureFrom","copyToTexture","buildRowMapping","mapping","columns","yOffset","i","xOffset","id","buildMapping","icons","buffer","rowHeight","canvasWidth","getDiffIcons","data","getIcon","cachedIcons","iterable","objectInfo","createIterable","object","IconManager","onUpdate","onError","__publicField","_a","loadOptions","autoPacking","iconAtlas","iconMapping","canvasHeight","Texture2D","load","ImageLoader","x","y","error"],"mappings":"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"}