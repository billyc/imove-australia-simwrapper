{"version":3,"file":"column-layer-fd2f0127.js","sources":["../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js","../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js"],"sourcesContent":["import { log } from '@deck.gl/core';\nimport { Geometry, uid } from '@luma.gl/core';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nexport default class ColumnGeometry extends Geometry {\n  constructor(props) {\n    const {\n      id = uid('column-geometry')\n    } = props;\n    const {\n      indices,\n      attributes\n    } = tesselateColumn(props);\n    super({ ...props,\n      id,\n      indices,\n      attributes\n    });\n  }\n\n}\n\nfunction tesselateColumn(props) {\n  const {\n    radius,\n    height = 1,\n    nradial = 10\n  } = props;\n  let {\n    vertices\n  } = props;\n\n  if (vertices) {\n    log.assert(vertices.length >= nradial);\n    vertices = vertices.flatMap(v => [v[0], v[1]]);\n    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);\n  }\n\n  const isExtruded = height > 0;\n  const vertsAroundEdge = nradial + 1;\n  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;\n  const stepAngle = Math.PI * 2 / nradial;\n  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  let i = 0;\n\n  if (isExtruded) {\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const a = j * stepAngle;\n      const vertexIndex = j % nradial;\n      const sin = Math.sin(a);\n      const cos = Math.cos(a);\n\n      for (let k = 0; k < 2; k++) {\n        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n        positions[i + 2] = (1 / 2 - k) * height;\n        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;\n        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;\n        i += 3;\n      }\n    }\n\n    positions[i + 0] = positions[i - 3];\n    positions[i + 1] = positions[i - 2];\n    positions[i + 2] = positions[i - 1];\n    i += 3;\n  }\n\n  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);\n    const a = v * stepAngle;\n    const vertexIndex = (v + nradial) % nradial;\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n    positions[i + 2] = height / 2;\n    normals[i + 2] = 1;\n    i += 3;\n  }\n\n  if (isExtruded) {\n    let index = 0;\n\n    for (let j = 0; j < nradial; j++) {\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 2;\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 3;\n    }\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      }\n    }\n  };\n}\n//# sourceMappingURL=column-geometry.js.map","export default \"#version 300 es\\n\\n#define SHADER_NAME column-layer-vertex-shader\\n\\nin vec3 positions;\\nin vec3 normals;\\n\\nin vec3 instancePositions;\\nin float instanceElevations;\\nin vec3 instancePositions64Low;\\nin vec4 instanceFillColors;\\nin vec4 instanceLineColors;\\nin float instanceStrokeWidths;\\n\\nin vec3 instancePickingColors;\\n\\n// Custom uniforms\\nuniform float opacity;\\nuniform float radius;\\nuniform float angle;\\nuniform vec2 offset;\\nuniform bool extruded;\\nuniform bool stroked;\\nuniform bool isStroke;\\nuniform float coverage;\\nuniform float elevationScale;\\nuniform float edgeDistance;\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform int radiusUnits;\\nuniform int widthUnits;\\n\\n// Result\\nout vec4 vColor;\\n#ifdef FLAT_SHADING\\nout vec4 position_commonspace;\\n#endif\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n\\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\\n  // rotate primitive position and normal\\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\\n\\n  // calculate elevation, if 3d not enabled set to 0\\n  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\\n  float elevation = 0.0;\\n  // calculate stroke offset\\n  float strokeOffsetRatio = 1.0;\\n\\n  if (extruded) {\\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\\n  } else if (stroked) {\\n    float widthPixels = clamp(\\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\\n      widthMinPixels, widthMaxPixels) / 2.0;\\n    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\\n    if (isStroke) {\\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\\n    } else {\\n      strokeOffsetRatio -= halfOffset;\\n    }\\n  }\\n\\n  // if alpha == 0.0 or z < 0.0, do not render element\\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\\n  float dotRadius = radius * coverage * shouldRender;\\n\\n  geometry.pickingColor = instancePickingColors;\\n\\n  // project center of column\\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\\n  vec3 centroidPosition64Low = instancePositions64Low;\\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\\n  if (radiusUnits == UNIT_METERS) {\\n    offset = project_size(offset);\\n  }\\n  vec3 pos = vec3(offset, 0.);\\n  DECKGL_FILTER_SIZE(pos, geometry);\\n\\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  // Light calculations\\n  if (extruded && !isStroke) {\\n#ifdef FLAT_SHADING\\n    position_commonspace = geometry.position;\\n    vColor = vec4(color.rgb, color.a * opacity);\\n#else\\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\\n    vColor = vec4(lightColor, color.a * opacity);\\n#endif\\n  } else {\\n    vColor = vec4(color.rgb, color.a * opacity);\\n  }\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=column-layer-vertex.glsl.js.map","export default \"#version 300 es\\n#define SHADER_NAME column-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform vec3 project_uCameraPosition;\\nuniform bool extruded;\\nuniform bool isStroke;\\n\\nout vec4 fragColor;\\n\\nin vec4 vColor;\\n#ifdef FLAT_SHADING\\nin vec4 position_commonspace;\\n#endif\\n\\nvoid main(void) {\\n  fragColor = vColor;\\n#ifdef FLAT_SHADING\\n  if (extruded && !isStroke && !picking_uActive) {\\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\\n  }\\n#endif\\n  DECKGL_FILTER_COLOR(fragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=column-layer-fragment.glsl.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, gouraudLighting, phongLighting, picking, UNIT } from '@deck.gl/core';\nimport { Model, isWebGL2, hasFeature, FEATURES } from '@luma.gl/core';\nimport ColumnGeometry from './column-geometry';\nimport vs from './column-layer-vertex.glsl';\nimport fs from './column-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  diskResolution: {\n    type: 'number',\n    min: 4,\n    value: 20\n  },\n  vertices: null,\n  radius: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  angle: {\n    type: 'number',\n    value: 0\n  },\n  offset: {\n    type: 'array',\n    value: [0, 0]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusUnits: 'meters',\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  extruded: true,\n  wireframe: false,\n  filled: true,\n  stroked: false,\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true,\n  getColor: {\n    deprecatedFor: ['getFillColor', 'getLineColor']\n  }\n};\nexport default class ColumnLayer extends Layer {\n  getShaders() {\n    const {\n      gl\n    } = this.context;\n    const transpileToGLSL100 = !isWebGL2(gl);\n    const defines = {};\n    const useDerivatives = this.props.flatShading && hasFeature(gl, FEATURES.GLSL_DERIVATIVES);\n\n    if (useDerivatives) {\n      defines.FLAT_SHADING = 1;\n    }\n\n    return super.getShaders({\n      vs,\n      fs,\n      defines,\n      transpileToGLSL100,\n      modules: [project32, useDerivatives ? phongLighting : gouraudLighting, picking]\n    });\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceElevations: {\n        size: 1,\n        transition: true,\n        accessor: 'getElevation'\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getLineWidth',\n        transition: true\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;\n\n    if (regenerateModels) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {\n      this._updateGeometry(props);\n    }\n  }\n\n  getGeometry(diskResolution, vertices, hasThinkness) {\n    const geometry = new ColumnGeometry({\n      radius: 1,\n      height: hasThinkness ? 2 : 0,\n      vertices,\n      nradial: diskResolution\n    });\n    let meanVertexDistance = 0;\n\n    if (vertices) {\n      for (let i = 0; i < diskResolution; i++) {\n        const p = vertices[i];\n        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n        meanVertexDistance += d / diskResolution;\n      }\n    } else {\n      meanVertexDistance = 1;\n    }\n\n    this.setState({\n      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance\n    });\n    return geometry;\n  }\n\n  _getModel(gl) {\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      isInstanced: true\n    });\n  }\n\n  _updateGeometry({\n    diskResolution,\n    vertices,\n    extruded,\n    stroked\n  }) {\n    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);\n    this.setState({\n      fillVertexCount: geometry.attributes.POSITION.value.length / 3,\n      wireframeVertexCount: geometry.indices.value.length\n    });\n    this.state.model.setProps({\n      geometry\n    });\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      radiusUnits,\n      elevationScale,\n      extruded,\n      filled,\n      stroked,\n      wireframe,\n      offset,\n      coverage,\n      radius,\n      angle\n    } = this.props;\n    const {\n      model,\n      fillVertexCount,\n      wireframeVertexCount,\n      edgeDistance\n    } = this.state;\n    model.setUniforms(uniforms).setUniforms({\n      radius,\n      angle: angle / 180 * Math.PI,\n      offset,\n      extruded,\n      stroked,\n      coverage,\n      elevationScale,\n      edgeDistance,\n      radiusUnits: UNIT[radiusUnits],\n      widthUnits: UNIT[lineWidthUnits],\n      widthScale: lineWidthScale,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels\n    });\n\n    if (extruded && wireframe) {\n      model.setProps({\n        isIndexed: true\n      });\n      model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({\n        isStroke: true\n      }).draw();\n    }\n\n    if (filled) {\n      model.setProps({\n        isIndexed: false\n      });\n      model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({\n        isStroke: false\n      }).draw();\n    }\n\n    if (!extruded && stroked) {\n      model.setProps({\n        isIndexed: false\n      });\n      model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({\n        isStroke: true\n      }).draw();\n    }\n  }\n\n}\n\n_defineProperty(ColumnLayer, \"layerName\", 'ColumnLayer');\n\n_defineProperty(ColumnLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=column-layer.js.map"],"names":["ColumnGeometry","Geometry","props","id","uid","indices","attributes","tesselateColumn","radius","height","nradial","vertices","log","v","modifyPolygonWindingDirection","WINDING","isExtruded","vertsAroundEdge","numVertices","stepAngle","positions","normals","i","j","a","vertexIndex","sin","cos","k","index","vs","fs","DEFAULT_COLOR","defaultProps","x","ColumnLayer","Layer","gl","transpileToGLSL100","isWebGL2","defines","useDerivatives","hasFeature","FEATURES","project32","phongLighting","gouraudLighting","picking","params","oldProps","changeFlags","regenerateModels","_this$state$model","diskResolution","hasThinkness","geometry","meanVertexDistance","p","d","Model","extruded","stroked","uniforms","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","radiusUnits","elevationScale","filled","wireframe","offset","coverage","angle","model","fillVertexCount","wireframeVertexCount","edgeDistance","UNIT","_defineProperty"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}