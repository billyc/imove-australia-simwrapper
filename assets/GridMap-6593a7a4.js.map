{"version":3,"file":"GridMap-6593a7a4.js","sources":["../../node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js","../../node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js","../../src/components/TimeSliderV2.vue","../../src/plugins/grid-map/GridLayer.tsx","../../src/plugins/grid-map/GridMap.vue"],"sourcesContent":["import Geometry from '../geometry/geometry';\nimport { uid } from '@luma.gl/webgl';\nconst CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);\nconst CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);\nconst CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);\nconst CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\nconst ATTRIBUTES = {\n  POSITION: {\n    size: 3,\n    value: new Float32Array(CUBE_POSITIONS)\n  },\n  NORMAL: {\n    size: 3,\n    value: new Float32Array(CUBE_NORMALS)\n  },\n  TEXCOORD_0: {\n    size: 2,\n    value: new Float32Array(CUBE_TEX_COORDS)\n  }\n};\nexport default class CubeGeometry extends Geometry {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = uid('cube-geometry')\n    } = props;\n    super({ ...props,\n      id,\n      indices: {\n        size: 1,\n        value: new Uint16Array(CUBE_INDICES)\n      },\n      attributes: { ...ATTRIBUTES,\n        ...props.attributes\n      }\n    });\n  }\n\n}\n//# sourceMappingURL=cube-geometry.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CubeGeometry } from '@luma.gl/core';\nimport { UNIT } from '@deck.gl/core';\nimport ColumnLayer from './column-layer';\nconst defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  offset: {\n    type: 'array',\n    value: [1, 1]\n  }\n};\nexport default class GridCellLayer extends ColumnLayer {\n  getGeometry(diskResolution) {\n    return new CubeGeometry();\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      elevationScale,\n      extruded,\n      offset,\n      coverage,\n      cellSize,\n      angle,\n      radiusUnits\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      radius: cellSize / 2,\n      radiusUnits: UNIT[radiusUnits],\n      angle,\n      offset,\n      extruded,\n      coverage,\n      elevationScale,\n      edgeDistance: 1,\n      isWireframe: false\n    }).draw();\n  }\n\n}\n\n_defineProperty(GridCellLayer, \"layerName\", 'GridCellLayer');\n\n_defineProperty(GridCellLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=grid-cell-layer.js.map","<template lang=\"pug\">\n.time-slider-component(v-if=\"hasNonZeroTimeRange\" :id=\"`id-${id}`\")\n  .label-area\n    p.p1 {{ state.labels[0] }}\n    p.p2(v-show=\"state.labels[1] !== undefined\") &nbsp;-&nbsp;{{ state.labels[1] }}\n\n  .slider-area\n    button.button.play-button(size=\"is-small\" type=\"is-link\"\n      @click=\"updateAnimation\"\n      ) {{ isAnimating ? '|&nbsp;|' : '>' }}\n\n    .time-slider-dragger(ref=\"slider\" @mousemove=\"dragging\")\n      .active-region(:style=\"calculateActiveMargins\"\n        @mousedown=\"dragStart\" @mouseup.stop=\"dragEnd\" @mousemove.stop=\"dragging\"\n      )\n\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nconst GRAB_HANDLE_WIDTH = 6\n\nenum DRAGTYPE {\n  SLIDE,\n  START,\n  END,\n}\n\nexport default defineComponent({\n  name: 'TimeSliderV2',\n  props: {\n    range: { type: Array as PropType<number[]>, required: true },\n    allTimes: [] as any[],\n  },\n  data: () => {\n    return {\n      state: {\n        componentWidth: 0,\n        dragStartX: 0,\n        dragType: DRAGTYPE.SLIDE,\n        isDragging: false,\n        isSetupComplete: false,\n        leftPosition: 0,\n        rightPosition: 1,\n        datasetRange: [0, 86400],\n        labels: ['', ''],\n        animationElapsedTime: 0,\n        startTime: 0,\n        timeFilter: [0, 3599],\n        animator: null as any,\n        timeLabels: [0, 1] as any[],\n        currentTime: 0 as number,\n      },\n      id: 'id-' + Math.floor(1e12 * Math.random()),\n      resizer: null as ResizeObserver | null,\n      ANIMATE_SPEED: 5,\n      isAnimating: false,\n    }\n  },\n  computed: {\n    // Calculate the total time span of the dataset.\n    fullDatasetTimeSpan(): number {\n      return this.state.datasetRange[1] - this.state.datasetRange[0] + this.allTimes[0]\n    },\n\n    // Calculate the extent from the left to the right position of the slider.\n    extentLeftToRight(): number {\n      return this.state.rightPosition - this.state.leftPosition\n    },\n\n    // Check if the time range is non-zero by comparing start and finish points.\n    hasNonZeroTimeRange(): boolean {\n      // Return false if the start and finish of the range are identical.\n      return !!this.fullDatasetTimeSpan\n    },\n\n    // Calculate the margins for the active region of the slider.\n    calculateActiveMargins(): any {\n      const usableWidth = this.state.componentWidth - 2 * GRAB_HANDLE_WIDTH\n      const marginLeft = Math.floor(usableWidth * this.state.leftPosition)\n      const marginRight = Math.floor(usableWidth * (1.0 - this.state.rightPosition))\n\n      return {\n        marginLeft: `${marginLeft}px`,\n        marginRight: `${marginRight}px`,\n      }\n    },\n  },\n\n  mounted() {\n    // Initialize component dimensions, initial values, and set up the resizer.\n    this.getDimensions()\n    this.setupInitialValues()\n    this.setupResizer()\n\n    // Add event listeners for mouseup and mousemove when the component is mounted.\n    window.addEventListener('mouseup', this.dragEnd)\n    window.addEventListener('mousemove', this.dragging)\n  },\n\n  beforeDestroy() {\n    // Remove event listeners for mouseup and mousemove before the component is destroyed.\n    window.removeEventListener('mouseup', this.dragEnd)\n    window.removeEventListener('mousemove', this.dragging)\n\n    // Cancel the animation frame if it's active to prevent memory leaks.\n    if (this.state.animator) window.cancelAnimationFrame(this.state.animator)\n  },\n\n  watch: {\n    // Watch for changes in 'state.currentTime' and trigger 'updateExtent' when it changes.\n    'state.currentTime'() {\n      this.updateExtent()\n    },\n\n    // Watch for changes in 'labels' and trigger 'updateLabels'.\n    labels() {\n      this.updateLabels()\n    },\n\n    // Watch for changes in 'state.leftPosition' and 'state.rightPosition', and call 'emitValues' to emit updated values.\n    'state.leftPosition'() {\n      this.emitValues()\n    },\n    'state.rightPosition'() {\n      this.emitValues()\n    },\n\n    // 'isAnimating'() {\n    //   this.updateAnimation();\n    // },\n  },\n\n  methods: {\n    /**\n     * Toggles the animation state and initiates or stops the animation loop accordingly.\n     */\n    updateAnimation() {\n      this.isAnimating = !this.isAnimating\n\n      if (this.isAnimating) {\n        // Calculate animation elapsed time and start time to control the animation.\n        this.state.animationElapsedTime = this.state.timeFilter[0] - this.range[0]\n        this.state.startTime = Date.now() - this.state.animationElapsedTime / this.ANIMATE_SPEED\n\n        // Initiate the animation loop.\n        this.animate()\n      }\n    },\n\n    /**\n     * Finds the index of the lower value in the sorted array 'this.allTimes' between which the given parameter lies.\n     *\n     * @param parameter - The value to search for to find the index in the 'this.allTimes' array.\n     * @returns The index of the lower value in the 'this.allTimes' array between which the given parameter lies.\n     *          If the parameter is smaller than the first entry in the array, -1 is returned.\n     */\n    findIndexLessThanOrEqualTo(parameter: number): number {\n      let left = 0\n      let right = this.allTimes.length - 1\n      let result = 0\n\n      while (left <= right) {\n        const mid = Math.floor((left + right) / 2)\n\n        if (this.allTimes[mid] === parameter) {\n          return mid\n        }\n\n        if (this.allTimes[mid] <= parameter) {\n          result = mid\n          left = mid + 1\n        } else {\n          right = mid - 1\n        }\n      }\n      return result\n    },\n\n    /**\n     * Controls the animation loop to update the current time and time filter.\n     * This method calculates the animation progress and updates the relevant state variables.\n     */\n    animate() {\n      if (!this.isAnimating) return\n\n      // Calculate animation elapsed time based on elapsed real-time and animation speed.\n      this.state.animationElapsedTime = this.ANIMATE_SPEED * (Date.now() - this.state.startTime)\n\n      // Calculate the current animation clock time.\n      const animationClockTime = this.state.animationElapsedTime + this.range[0]\n\n      // Update the current time based on the animation clock time.\n      this.state.currentTime = this.findIndexLessThanOrEqualTo(animationClockTime)\n\n      // Check if animation has reached the end of the range.\n      if (animationClockTime > this.range[1] + this.allTimes[0]) {\n        // Restart the animation if it exceeds the range.\n        this.state.startTime = Date.now()\n        this.state.animationElapsedTime = 0\n      }\n\n      // Update the time filter based on the current time.\n      this.state.timeFilter = [\n        this.allTimes[this.state.currentTime],\n        this.allTimes[this.state.currentTime + 1] == undefined\n          ? 0\n          : this.allTimes[this.state.currentTime + 1],\n      ]\n\n      // Request the next animation frame to continue the loop.\n      this.state.animator = window.requestAnimationFrame(this.animate)\n    },\n\n    /**\n     * Sets up a ResizeObserver to monitor changes in component dimensions.\n     * This method attempts to create a ResizeObserver and attach it to the component's DOM element.\n     */\n    setupResizer() {\n      try {\n        // Create a ResizeObserver instance and observe the component's DOM element.\n        this.resizer = new ResizeObserver(this.getDimensions)\n        const sliderElement = document.getElementById(`id-${this.id}`) as HTMLElement\n        this.resizer.observe(sliderElement)\n      } catch (e) {\n        console.error('' + e)\n      }\n    },\n\n    /**\n     * Calculates and sets the initial values for the component's state.\n     * This method initializes dataset range, time filter, and slider positions.\n     */\n    setupInitialValues() {\n      try {\n        // If 'range' is provided, set dataset range and initial time filter.\n        if (this.range) {\n          this.state.datasetRange = this.range\n          this.state.timeFilter = [this.allTimes[0], this.allTimes[1]]\n        }\n\n        // Check if the full dataset time span is zero.\n        if (this.fullDatasetTimeSpan === 0) {\n          this.state.leftPosition = 0\n          this.state.rightPosition = 1\n        } else {\n          // Calculate and update slider positions based on the dataset range.\n          this.updateExtent()\n        }\n      } catch (e) {\n        console.error('' + e)\n        // Handle potential division by zero.\n      } finally {\n        // Mark the setup as complete.\n        this.state.isSetupComplete = true\n      }\n    },\n\n    /**\n     * Updates the slider positions and time labels based on the current time filter.\n     * This method recalculates and sets the left and right slider positions as well as time labels.\n     */\n    updateExtent() {\n      if (!this.state.timeFilter) return\n\n      // Calculate the left and right slider positions based on the current time filter.\n      this.state.leftPosition =\n        (1 / this.fullDatasetTimeSpan) * (this.allTimes[this.state.currentTime] - this.allTimes[0])\n      this.state.rightPosition =\n        (1 / this.fullDatasetTimeSpan) *\n        (this.allTimes[this.state.currentTime + 1] == undefined\n          ? this.allTimes[this.state.currentTime] + this.allTimes[0]\n          : this.allTimes[this.state.currentTime + 1] - this.allTimes[0])\n\n      // Calculate and set time labels.\n      this.state.timeLabels = [\n        this.convertSecondsToClockTimeMinutes(this.allTimes[this.state.currentTime]),\n        this.convertSecondsToClockTimeMinutes(\n          this.allTimes[this.state.currentTime + 1] == undefined\n            ? this.allTimes[this.state.currentTime] + this.allTimes[0]\n            : this.allTimes[this.state.currentTime + 1]\n        ),\n      ]\n\n      // Update labels and complete the update.\n      this.updateLabels()\n    },\n\n    /**\n     * Updates component labels with time labels if available in the state.\n     */\n    updateLabels() {\n      // If time labels are available in the state, update component labels.\n      if (this.state.timeLabels) this.state.labels = this.state.timeLabels\n    },\n\n    /**\n     * Emits time extent values to the parent component when setup is complete.\n     * This method emits the current time filter values to the parent component.\n     */\n    emitValues() {\n      // Check if setup is complete before emitting time extent values.\n      if (!this.state.isSetupComplete) return\n\n      // Emit the current time filter values to the parent component.\n      this.$emit('timeExtent', this.state.timeFilter)\n    },\n\n    /**\n     * Converts a time value in seconds to a clock-style time format in hours and minutes.\n     *\n     * @param index - The time value in seconds to be converted.\n     * @returns A formatted string in the 'hh:mm' clock time format.\n     */\n    convertSecondsToClockTimeMinutes(index: number) {\n      const h = Math.floor(index / 3600)\n      const m = Math.floor((index - h * 3600) / 60)\n\n      // Calculate seconds separately.\n      const s = index - h * 3600 - m * 60\n\n      // Create an object to represent hours, minutes, and seconds.\n      const hms = { h: `${h}`, m: `${m}`.padStart(2, '0'), s: `${s}`.padStart(2, '0') }\n\n      // Return the formatted clock time string.\n      return `${hms.h}:${hms.m}`\n    },\n\n    // Calculates the width of the element\n    getDimensions() {\n      //@ts-ignore - ref doesn't know about clientWidth\n      this.state.componentWidth = this.$refs.slider?.clientWidth || 0\n    },\n\n    /**\n     * Initiates a dragging operation when a mouse click event occurs.\n     *\n     * @param e - The MouseEvent object containing event details.\n     * @emits drag - Emits a 'drag' event to notify parent components of the drag operation.\n     */\n    dragStart(e: MouseEvent) {\n      // Set the 'isDragging' flag to true to indicate a drag operation.\n      this.state.isDragging = true\n\n      // Store the initial mouse position when dragging starts.\n      this.state.dragStartX = e.clientX\n\n      // Calculate various dimensions and update the drag type based on mouse position.\n      const usableWidth = this.state.componentWidth - 2 * GRAB_HANDLE_WIDTH\n      const marginLeft = Math.floor(usableWidth * this.state.leftPosition)\n      const marginRight = Math.floor(usableWidth * (1.0 - this.state.rightPosition))\n\n      // Calculate the width of the time duration area within the slider.\n      const durationWidth =\n        this.state.componentWidth - marginRight - marginLeft - 2 * GRAB_HANDLE_WIDTH\n\n      // Determine the drag type based on the mouse position within the duration area.\n      if (e.offsetX >= 0 && e.offsetX < durationWidth) this.state.dragType = DRAGTYPE.SLIDE\n      else if (e.offsetX < 0) this.state.dragType = DRAGTYPE.START\n      else if (e.offsetX > durationWidth) this.state.dragType = DRAGTYPE.END\n    },\n\n    /**\n     * Handles dragging operations based on mouse movement during dragging.\n     *\n     * @param e - The MouseEvent object containing event details.\n     */\n    dragging(e: MouseEvent) {\n      if (!this.state.isDragging) return\n\n      // Calculate the horizontal movement distance (deltaX) of the mouse.\n      const deltaX = e.clientX - this.state.dragStartX\n      const usableWidth = this.state.componentWidth - 2 * GRAB_HANDLE_WIDTH\n\n      // Check the type of drag operation and update positions accordingly.\n      if (DRAGTYPE.SLIDE == this.state.dragType) {\n        const currentExtent = this.extentLeftToRight\n        let newLeft = (usableWidth * this.state.leftPosition + deltaX) / usableWidth\n        let newRight = newLeft + currentExtent\n\n        // Ensure the draggable window does not exceed the slider's boundaries.\n        if (newLeft < 0) {\n          newLeft = 0\n          newRight = currentExtent\n        }\n\n        if (newRight > 1) {\n          newRight = 1\n          newLeft = newRight - currentExtent\n        }\n\n        this.state.leftPosition = newLeft\n        this.state.rightPosition = newRight\n\n        this.updateLabels()\n        this.updateData()\n\n        this.state.dragStartX = e.clientX\n        return\n      }\n    },\n\n    /**\n     * Handles the end of a dragging operation, resetting the dragging state.\n     *\n     * @param e - The event object associated with the drag end event.\n     */\n    dragEnd(e: MouseEvent) {\n      const newStartTime = this.findIndexLessThanOrEqualTo(\n        this.state.leftPosition * this.fullDatasetTimeSpan + this.allTimes[0]\n      )\n\n      this.state.leftPosition =\n        (1 / this.fullDatasetTimeSpan) * (this.allTimes[newStartTime] - this.allTimes[0])\n      this.state.rightPosition =\n        (1 / this.fullDatasetTimeSpan) *\n        (this.allTimes[newStartTime + 1] == undefined\n          ? this.allTimes[newStartTime] + this.allTimes[0]\n          : this.allTimes[newStartTime + 1] - this.allTimes[0])\n\n      this.state.timeFilter = [\n        this.allTimes[newStartTime] - this.allTimes[0],\n        this.allTimes[newStartTime + 1] == undefined\n          ? this.allTimes[newStartTime] + this.allTimes[0]\n          : this.allTimes[newStartTime + 1] - this.allTimes[0],\n      ]\n\n      this.state.isDragging = false\n    },\n\n    updateData() {\n      const newStartTime = this.findIndexLessThanOrEqualTo(\n        this.state.leftPosition * this.fullDatasetTimeSpan + this.allTimes[0]\n      )\n\n      const newEndTime =\n        this.findIndexLessThanOrEqualTo(\n          this.state.leftPosition * this.fullDatasetTimeSpan + this.allTimes[0]\n        ) + 1\n\n      // Calculate and set time labels.\n      this.state.timeLabels = [\n        this.convertSecondsToClockTimeMinutes(this.allTimes[newStartTime]),\n        this.convertSecondsToClockTimeMinutes(this.allTimes[newEndTime]),\n      ]\n\n      this.state.timeFilter = [this.allTimes[newStartTime], this.allTimes[newEndTime]]\n    },\n  },\n})\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.time-slider-component {\n  display: flex;\n  flex-direction: column;\n}\n\n.slider-area {\n  background-color: var(--bgPanel);\n  padding: 1rem 1rem;\n  display: flex;\n  flex-direction: row;\n}\n\n.time-slider-dragger {\n  user-select: none;\n  height: 1.5rem;\n  background-color: #66669933;\n  border-radius: 4px;\n  max-width: 100%;\n  flex: 1;\n  overflow: hidden;\n}\n\n.active-region {\n  cursor: ew-resize;\n  color: white;\n  background-color: var(--sliderThumb);\n  height: 100%;\n  border-radius: 4px;\n  border-left: 6px solid var(--linkHover);\n  border-right: 6px solid var(--linkHover);\n  font-size: 1rem;\n  line-height: 0.6rem;\n}\n\n.label-area {\n  margin: 0 0;\n  font-size: 1.3rem;\n  font-weight: bold;\n  display: flex;\n  flex-direction: row;\n  margin-right: auto;\n}\n\n.p1 {\n  padding: 0 0;\n  padding-left: 1rem;\n  background-color: var(--bgPanel);\n}\n\n.p2 {\n  padding: 0 0;\n  padding-right: 1rem;\n  background-color: var(--bgPanel);\n}\n\n.play-button {\n  width: 2.4rem;\n  height: 1.5rem;\n  margin-right: 1rem;\n  font-weight: bold;\n  font-size: 0.8rem;\n  line-height: 0.8rem;\n  padding: 0 0;\n}\n</style>\n","import React, { useState } from 'react'\nimport DeckGL from '@deck.gl/react'\nimport { StaticMap } from 'react-map-gl'\nimport { GridCellLayer } from '@deck.gl/layers'\nimport colormap from 'colormap'\n\nimport globalStore from '@/store' // Import global state management store.\nimport { MAPBOX_TOKEN, REACT_VIEW_HANDLES } from '@/Globals' // Import constants and configurations.\n\nimport { CompleteMapData } from './GridMap.vue' // Import data types.\n\nconst material = {\n  ambient: 0.64,\n  diffuse: 0.6,\n  shininess: 32,\n  specularColor: [51, 51, 51],\n}\n\n// LAYER --------------------------------------------------------\nexport default function Layer({\n  viewId = 0 as number,\n  colorRamp = 'viridis' as String,\n  dark = false as Boolean,\n  data = {} as CompleteMapData,\n  currentTimeIndex = 0 as number,\n  // extrude = true as Boolean,\n  mapIsIndependent = false as Boolean,\n  maxHeight = 200 as Number,\n  cellSize = 200 as Number,\n  opacity = 0.7 as Number,\n  upperPercentile = 100 as Number,\n}) {\n  // manage SimWrapper centralized viewState - for linked maps\n  const [viewState, setViewState] = useState(globalStore.state.viewState)\n\n  // Handle view state changes\n  REACT_VIEW_HANDLES[viewId] = (view: any) => {\n    if (view) {\n      setViewState(view)\n    } else {\n      setViewState(globalStore.state.viewState)\n    }\n  }\n\n  // Function to handle view state changes\n  function handleViewState(view: any) {\n    // Make shure that latitude and longitude exist in the view object\n    if (!view || typeof view.latitude !== 'number' || typeof view.longitude !== 'number') {\n      return\n    }\n\n    // If the view does not have a center, initialize it to [0, 0]\n    if (!view.center) {\n      view.center = [0, 0]\n    }\n\n    // Set the center based on longitude and latitude\n    view.center[0] = view.longitude\n    view.center[1] = view.latitude\n\n    // Update the view state\n    setViewState(view)\n\n    // Update the global map camera position if it's not independent\n    if (!mapIsIndependent) {\n      globalStore.commit('setMapCamera', view)\n    }\n  }\n\n  // Generate colors for data visualization using the specified color ramp\n  const colors = colormap({\n    colormap: colorRamp,\n    nshades: 10,\n    format: 'rba',\n    alpha: 1,\n  }).map((c: number[]) => [c[0], c[1], c[2], 255])\n\n  const layers = [\n    new GridCellLayer({\n      id: 'gridlayer',\n      data: {\n        length: data.mapData[currentTimeIndex].length,\n        attributes: {\n          getPosition: { value: data.mapData[currentTimeIndex].centroid, size: 2 },\n          getFillColor: { value: data.mapData[currentTimeIndex].colorData, size: 3 },\n          getElevation: { value: data.mapData[currentTimeIndex].values, size: 1 },\n        },\n      },\n      colorRange: dark ? colors.slice(1) : colors.reverse().slice(1),\n      coverage: 1,\n      autoHighlight: true,\n      elevationRange: [0, maxHeight],\n      elevationScale: maxHeight,\n      pickable: true,\n      opacity,\n      cellSize,\n      upperPercentile,\n      material: false,\n      transitions: {\n        elevationScale: { type: 'interpolation', duration: 10 },\n        opacity: { type: 'interpolation', duration: 200 },\n      },\n      parameters: {\n        // fixes the z-fighting problem but makes some issues with the opacity...\n        // depthTest: false,\n      },\n    }),\n  ]\n\n  // Render the Deck.gl map component with specified props\n  return (\n    <DeckGL\n      layers={layers}\n      controller={true}\n      useDevicePixels={false}\n      viewState={viewState}\n      onViewStateChange={(e: any) => handleViewState(e.viewState)}\n    >\n      {/* @ts-ignore */}\n      <StaticMap\n        mapStyle={globalStore.getters.mapStyle}\n        preventStyleDiffing={true}\n        mapboxApiAccessToken={MAPBOX_TOKEN}\n      />\n    </DeckGL>\n  )\n}\n","<template lang=\"pug\">\n.xy-hexagons(:class=\"{'hide-thumbnail': !thumbnail}\" oncontextmenu=\"return false\" :id=\"`id-${id}`\")\n\n      grid-layer(\n        v-if=\"!thumbnail && isLoaded\"\n        v-bind=\"mapProps\"\n      )\n\n      zoom-buttons(v-if=\"!thumbnail && isLoaded\" corner=\"bottom\")\n\n      .top-right\n        .gui-config(:id=\"configId\")\n\n      time-slider.time-slider-area(v-if=\"isLoaded\"\n        :range=\"timeRange\"\n        :allTimes=\"allTimes\"\n        @timeExtent=\"handleTimeSliderValues\"\n      )\n\n      .message(v-if=\"!thumbnail && myState.statusMessage\")\n        p.status-message {{ myState.statusMessage }}\n\n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue'\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nimport GUI from 'lil-gui'\nimport { ToggleButton } from 'vue-js-toggle-button'\nimport YAML from 'yaml'\nimport colormap from 'colormap'\nimport { colorRamp, Ramp, Style } from '@/js/ColorsAndWidths'\n\nimport util from '@/js/util'\nimport globalStore from '@/store'\nimport { REACT_VIEW_HANDLES } from '@/Globals'\nimport HTTPFileSystem from '@/js/HTTPFileSystem'\nimport Coords from '@/js/Coords'\nimport DashboardDataManager from '@/js/DashboardDataManager'\nimport CollapsiblePanel from '@/components/CollapsiblePanel.vue'\nimport DrawingTool from '@/components/DrawingTool/DrawingTool.vue'\nimport ZoomButtons from '@/components/ZoomButtons.vue'\nimport TimeSlider from '@/components/TimeSliderV2.vue'\n\nimport GridLayer from './GridLayer'\nimport { ColorScheme, FileSystemConfig, Status } from '@/Globals'\nimport { thresholdFreedmanDiaconis } from 'd3-array'\n\n// interface for each time object inside the mapData Array\nexport interface MapData {\n  time: Number\n  colorData: Uint8Array\n  values: Float32Array\n  centroid: Float32Array\n  numberOfFilledColors?: Number\n  numberOfFilledValues?: Number\n  numberOfFilledCentroids?: Number\n  length: Number\n}\n\nexport interface CompleteMapData {\n  mapData: MapData[]\n  scaledFactor: Number\n}\n\ninterface VizDetail {\n  title: string\n  description?: string\n  file: string\n  projection: any\n  thumbnail?: string\n  elements?: string\n  cellSize: number\n  maxHeight: number\n  userColorRamp: string\n  opacity: number\n  center: any\n  zoom: number\n  mapIsIndependent?: boolean\n  breakpoints?: string\n}\n\ninterface GuiConfig {\n  buckets: number\n  exponent: number\n  radius: number\n  opacity: number\n  height: number\n  'color ramp': string\n  colorRamps: String[]\n  flip: Boolean\n  steps: number\n}\n\ninterface StandaloneYAMLconfig {\n  title: String\n  description: String\n  file: String\n  projection: String\n  thumbnail: String\n  cellSize: number\n  opacity: number\n  maxHeight: number\n  userColorRamp: string\n  center: number[]\n  zoom: number\n  mapIsIndependent: boolean\n}\n\ninterface MapProps {\n  viewId: string\n  colorRamp: String\n  coverage: number\n  dark: boolean\n  data: CompleteMapData\n  currentTimeIndex: number | undefined\n  mapIsIndependent: boolean | undefined\n  maxHeight: number\n  userColorRamp: string\n  cellSize: number\n  opacity: number\n  upperPercentile: number\n}\n\nconst i18n = {\n  messages: {\n    en: {\n      loading: 'Loading data...',\n      sorting: 'Sorting into bins...',\n      aggregate: 'Summary',\n      maxHeight: '3D Height',\n      showDetails: 'Show Details',\n      selection: 'Selection',\n      areas: 'Areas',\n      count: 'Count',\n    },\n    de: {\n      loading: 'Dateien laden...',\n      sorting: 'Sortieren...',\n      aggregate: 'Daten',\n      maxHeight: '3-D Höhe',\n      showDetails: 'Details anzeigen',\n      selection: 'Ausgewählt',\n      areas: 'Orte',\n      count: 'Anzahl',\n    },\n  },\n}\n\nconst GridMap = defineComponent({\n  name: 'GridMapPlugin',\n  i18n,\n  components: {\n    CollapsiblePanel,\n    DrawingTool,\n    GridLayer,\n    ToggleButton,\n    ZoomButtons,\n    TimeSlider,\n  },\n  props: {\n    root: { type: String, required: true },\n    subfolder: { type: String, required: true },\n    yamlConfig: String,\n    config: Object,\n    thumbnail: Boolean,\n    datamanager: { type: Object as PropType<DashboardDataManager>, required: true },\n  },\n  data: () => {\n    const colorRamps = ['Inferno', 'Magma', 'Viridis', 'Greens', 'Reds', 'RdYlGn', 'greenRed']\n    return {\n      id: `id-${Math.floor(1e12 * Math.random())}` as any,\n      standaloneYAMLconfig: {\n        title: '',\n        description: '',\n        file: '',\n        projection: '',\n        thumbnail: '',\n        cellSize: 250,\n        opacity: 0.7,\n        maxHeight: 0,\n        userColorRamp: 'virdis',\n        center: null as any,\n        zoom: 9,\n        mapIsIndependent: false,\n      } as StandaloneYAMLconfig,\n      colorRamps,\n      columnLookup: [] as number[],\n      gzipWorker: null as Worker | null,\n      colorRamp: colorRamps[0] as String,\n      globalState: globalStore.state,\n      vizDetails: {\n        title: '',\n        description: '',\n        file: '',\n        projection: '',\n        thumbnail: '',\n        cellSize: 250,\n        opacity: 0.7,\n        maxHeight: 0,\n        userColorRamp: 'virdis',\n        center: null as any,\n        zoom: 9,\n        breakpoints: null as any,\n      } as VizDetail,\n      myState: {\n        statusMessage: '',\n        subfolder: '',\n        yamlConfig: '',\n        thumbnail: false,\n      },\n      data: null as any,\n      selectedTimeData: [] as any[],\n      allTimePeriodes: [] as any[],\n      colors: colormap({\n        colormap: 'viridis',\n        nshades: 10,\n        format: 'rba',\n        alpha: 1,\n      }).map((c: number[]) => [c[0], c[1], c[2], 255]) as Uint8Array[],\n      currentTime: [0, 0] as Number[],\n      timeToIndex: new Map<Number, number>(),\n      guiConfig: {\n        buckets: 10,\n        exponent: 4,\n        radius: 5,\n        opacity: 1,\n        height: 100,\n        'color ramp': 'viridis',\n        colorRamps: colorRamps,\n        flip: false,\n        steps: 10,\n      } as GuiConfig,\n      configId: `gui-config-${Math.floor(1e12 * Math.random())}` as string,\n      guiController: null as GUI | null,\n      minRadius: 50 as number,\n      maxRadius: 300 as number,\n      radiusStep: 5 as number,\n      isLoaded: false as boolean,\n      thumbnailUrl: \"url('assets/thumbnail.jpg') no-repeat;\" as string,\n      resizer: null as ResizeObserver | null,\n      timeRange: [Infinity, -Infinity] as Number[],\n      allTimes: [] as number[],\n    }\n  },\n  computed: {\n    fileApi(): HTTPFileSystem {\n      return new HTTPFileSystem(this.fileSystem, globalStore)\n    },\n    fileSystem(): FileSystemConfig {\n      const svnProject: FileSystemConfig[] = this.$store.state.svnProjects.filter(\n        (a: FileSystemConfig) => a.slug === this.root\n      )\n      if (svnProject.length === 0) {\n        console.log('no such project')\n        throw Error\n      }\n      return svnProject[0]\n    },\n\n    urlThumbnail(): any {\n      return this.thumbnailUrl\n    },\n\n    mapProps(): MapProps {\n      return {\n        viewId: this.id,\n        colorRamp: this.colorRamp,\n        coverage: 0.65,\n        dark: this.$store.state.isDarkMode,\n        data: this.data,\n        currentTimeIndex: this.timeToIndex.get(this.currentTime[0]),\n        mapIsIndependent: this.vizDetails.mapIsIndependent,\n        maxHeight: this.guiConfig.height,\n        userColorRamp: this.guiConfig['color ramp'],\n        cellSize: this.guiConfig.radius,\n        opacity: this.guiConfig.opacity,\n        upperPercentile: 100,\n      }\n    },\n    textColor(): any {\n      const lightmode = {\n        text: '#3498db',\n        bg: '#eeeef480',\n      }\n\n      const darkmode = {\n        text: 'white',\n        bg: '#181518aa',\n      }\n\n      return this.$store.state.colorScheme === ColorScheme.DarkMode ? darkmode : lightmode\n    },\n  },\n  watch: {\n    '$store.state.viewState'() {\n      if (this.vizDetails.mapIsIndependent) return\n      if (REACT_VIEW_HANDLES[this.id]) REACT_VIEW_HANDLES[this.id]()\n    },\n  },\n  methods: {\n    /**\n     * Selects a color based on the given value.\n     * @param {number} value - The value influencing color selection (0-100).\n     * @returns {number[]} - An RGBA color array [R, G, B, A].\n     */\n    pickColor(value: number): number[] | Uint8Array {\n      // Error handling: If the value is outside the valid range, return a default color.\n      if (value < 0 || value > 100) {\n        console.warn('Invalid value for pickColor: Value should be between 0 and 100.')\n        return [0, 0, 0, 0] // Default color (transparent)\n      }\n\n      // if (value.toString() === '0') {\n      //   value = Number.MIN_VALUE\n      // }\n\n      // Calculate the index based on the value and the number of colors in the array.\n      const index = Math.floor((value / 100) * (this.colors.length - 1))\n\n      // Return the selected color.\n      return this.colors[index]\n    },\n\n    async solveProjection() {\n      console.log('solveProjection')\n      if (this.thumbnail) return\n\n      console.log('WHAT PROJECTION:')\n\n      try {\n        const text = await this.fileApi.getFileText(\n          this.myState.subfolder + '/' + this.myState.yamlConfig\n        )\n        this.vizDetails = YAML.parse(text)\n      } catch (e) {\n        console.error(e)\n      }\n    },\n\n    async getVizDetails() {\n      if (this.config) {\n        this.validateYAML()\n        this.vizDetails = Object.assign({}, this.config) as VizDetail\n        this.setRadiusAndHeight()\n        this.setCustomGuiConfig()\n        return\n      }\n\n      const hasYaml = new RegExp('.*(yml|yaml)$').test(this.myState.yamlConfig)\n\n      if (hasYaml) {\n        await this.loadStandaloneYAMLConfig()\n      } else {\n        this.loadOutputTripsConfig()\n      }\n    },\n\n    loadOutputTripsConfig() {\n      let projection = 'EPSG:31468' // 'EPSG:25832', // 'EPSG:31468', // TODO: fix\n      if (!this.myState.thumbnail) {\n        projection = prompt('Enter projection: e.g. \"EPSG:31468\"') || 'EPSG:31468'\n        if (!!parseInt(projection, 10)) projection = 'EPSG:' + projection\n      }\n      this.vizDetails = {\n        title: 'Output Trips',\n        description: this.myState.yamlConfig,\n        file: this.myState.yamlConfig,\n        projection,\n        cellSize: this.vizDetails.cellSize,\n        opacity: this.vizDetails.opacity,\n        maxHeight: this.vizDetails.maxHeight,\n        userColorRamp: this.vizDetails.userColorRamp,\n        center: this.vizDetails.center,\n        zoom: this.vizDetails.zoom,\n      }\n      this.$emit('title', this.vizDetails.title)\n      this.solveProjection()\n      return\n    },\n\n    // TODO: Set default values for color attributes\n    setRadiusAndHeight() {\n      if (!this.vizDetails.cellSize) {\n        Vue.set(this.vizDetails, 'cellSize', 250)\n      }\n\n      if (!this.vizDetails.maxHeight) {\n        Vue.set(this.vizDetails, 'maxHeight', 0)\n      }\n\n      if (!this.vizDetails.opacity) {\n        Vue.set(this.vizDetails, 'opacity', 0.7)\n      }\n    },\n\n    async loadStandaloneYAMLConfig() {\n      try {\n        // Determine the full filename, handling cases where yamlConfig might include '/'\n        const filename = this.myState.yamlConfig.includes('/')\n          ? this.myState.yamlConfig\n          : `${this.myState.subfolder}/${this.myState.yamlConfig}`\n\n        // Load the YAML file and store it in standaloneYAMLconfig\n        const text = await this.fileApi.getFileText(filename)\n        this.standaloneYAMLconfig = YAML.parse(text)\n\n        // YAML file validation\n        this.validateYAML()\n\n        // Set visualization details\n        this.setVizDetails()\n      } catch (err) {\n        // Show error message in the Warning/Error Panel\n        const errorMessage = `File not found: ${this.myState.subfolder}/${this.myState.yamlConfig}`\n        this.$store.commit('setStatus', {\n          type: Status.ERROR,\n          msg: 'Error',\n          desc: errorMessage,\n        })\n      }\n    },\n\n    validateYAML() {\n      const hasYaml = new RegExp('.*(yml|yaml)$').test(this.myState.yamlConfig)\n      let configuration = {} as any\n\n      if (hasYaml) {\n        console.log('has yaml')\n        configuration = this.standaloneYAMLconfig\n      } else {\n        console.log('no yaml')\n        configuration = this.config\n      }\n\n      if (configuration.cellSize == 0) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `Radius is out of the recommended range`,\n          desc: 'Radius can not be zero, preset value used instead. ',\n        })\n      }\n\n      if (configuration.opacity <= 0 || configuration.opacity > 1) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `Opacity set to zero`,\n          desc: 'Opacity levels should be between 0 and 1. ',\n        })\n      }\n\n      if (configuration.zoom < 5 || configuration.zoom > 20) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `Zoom is out of the recommended range `,\n          desc: 'Zoom levels should be between 5 and 20. ',\n        })\n      }\n\n      if (configuration.maxHeight < 0) {\n        this.$store.commit('setStatus', {\n          type: Status.WARNING,\n          msg: `maxHeight is out of the recommended range `,\n          desc: 'maxHeight should be greater than 0',\n        })\n      }\n\n      // TODO: Add warnings for color attributes\n    },\n\n    setVizDetails() {\n      this.vizDetails = Object.assign({}, this.vizDetails, this.standaloneYAMLconfig)\n\n      this.setRadiusAndHeight()\n\n      const t = this.vizDetails.title ? this.vizDetails.title : 'Hex Aggregation'\n      this.$emit('title', t)\n    },\n\n    async buildThumbnail() {\n      if (this.thumbnail && this.vizDetails.thumbnail) {\n        try {\n          const blob = await this.fileApi.getFileBlob(\n            this.myState.subfolder + '/' + this.vizDetails.thumbnail\n          )\n          const buffer = await blob.arrayBuffer()\n          const base64 = util.arrayBufferToBase64(buffer)\n          if (base64)\n            this.thumbnailUrl = `center / cover no-repeat url(data:image/png;base64,${base64})`\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n\n    setMapCenter() {\n      // If user gave us the center, use it\n      if (this.vizDetails.center) {\n        if (typeof this.vizDetails.center == 'string') {\n          this.vizDetails.center = this.vizDetails.center.split(',').map(Number)\n        }\n\n        const view = {\n          longitude: this.vizDetails.center[0],\n          latitude: this.vizDetails.center[1],\n          bearing: 10,\n          pitch: 0,\n          zoom: this.vizDetails.zoom || 10, // use 10 default if we don't have a zoom\n          jump: true, // move the map no matter what\n          center: [this.vizDetails.center[0], this.vizDetails.center[1]],\n        }\n\n        // bounce our map\n        if (REACT_VIEW_HANDLES[this.id]) REACT_VIEW_HANDLES[this.id](view)\n\n        // Sets the map to the specified data\n        this.$store.commit('setMapCamera', view)\n\n        return\n      }\n    },\n\n    async loadAndPrepareData() {\n      const config = {\n        dataset: this.vizDetails.file,\n      }\n\n      const csv = await this.datamanager.getDataset(config)\n\n      // The datamanager doesn't return the comments...\n      // const projection = csv.comments[0].split('#')[1].trim()\n      // if (projection) this.vizDetails.projection = projection\n\n      // Store the min and max value to calculate the scale factor\n      let minValue = Number.POSITIVE_INFINITY\n      let maxValue = Number.NEGATIVE_INFINITY\n\n      // This for loop collects all the data that's used by\n      for (let i = 0; i < csv.allRows.value.values.length; i++) {\n        // Stores all times to calculate the range and the timeBinSize\n        if (!this.allTimes.includes(csv.allRows.time.values[i]))\n          this.allTimes.push(csv.allRows.time.values[i])\n\n        // calculate the min and max value\n        if (csv.allRows.value.values[i] < minValue) minValue = csv.allRows.value.values[i]\n        if (csv.allRows.value.values[i] > maxValue) maxValue = csv.allRows.value.values[i]\n\n        // Store all different times\n        if (!this.allTimes.includes(csv.allRows.time.values[i]))\n          this.allTimes.push(csv.allRows.time.values[i])\n      }\n\n      this.allTimes = this.allTimes.sort((n1, n2) => n1 - n2)\n\n      this.timeRange[0] = Math.min.apply(Math, this.allTimes)\n      this.timeRange[1] = Math.max.apply(Math, this.allTimes)\n\n      // Count elements per time\n      const numberOfElementsPerTime = Math.ceil(\n        csv.allRows.value.values.length / this.allTimes.length\n      )\n\n      // scaleFactor\n      const scaleFactor = 100 / maxValue\n\n      const finalData = {\n        mapData: [] as MapData[],\n        scaledFactor: scaleFactor as Number,\n      } as CompleteMapData\n\n      // map all times to their index and create a mapData object for each time\n      this.allTimes.forEach((time, index) => {\n        this.timeToIndex.set(time, index)\n\n        finalData.mapData.push({\n          time: time,\n          values: new Float32Array(numberOfElementsPerTime),\n          centroid: new Float32Array(numberOfElementsPerTime * 2),\n          colorData: new Uint8Array(numberOfElementsPerTime * 3),\n          numberOfFilledValues: 0,\n          numberOfFilledCentroids: 0,\n          numberOfFilledColors: 0,\n          length: numberOfElementsPerTime,\n        })\n      })\n\n      // User must provide projection\n      if (!this.vizDetails.projection) {\n        const msg = 'No coordinate projection. Add \"projection: EPSG:xxxx\" to config'\n        this.$emit('error', msg)\n        throw Error(msg)\n      }\n\n      // Loop through the data and create the data object for the map\n      for (let i = 0; i < csv.allRows.value.values.length; i++) {\n        // index for the time\n        const index = this.timeToIndex.get(csv.allRows.time.values[i]) as number\n\n        const value = scaleFactor * csv.allRows.value.values[i]\n        const colors = this.pickColor(value)\n\n        // Save index for next position in the array\n        const lastValueIndex = finalData.mapData[index].numberOfFilledValues as number\n        const lastColorIndex = finalData.mapData[index].numberOfFilledColors as number\n        const lastCentroidIndex = finalData.mapData[index].numberOfFilledCentroids as number\n\n        // Save the value\n        finalData.mapData[index].values[lastValueIndex] = value\n\n        // Loop through the colors and add them to the mapData\n        for (let j = 0; j < 3; j++) {\n          finalData.mapData[index].colorData[lastColorIndex + j] = colors[j]\n        }\n\n        // Convert coordinates\n        let wgs84 = [csv.allRows.x.values[i], csv.allRows.y.values[i]]\n\n        if (this.vizDetails.projection !== 'EPSG:4326') {\n          wgs84 = Coords.toLngLat(this.vizDetails.projection, [\n            csv.allRows.x.values[i],\n            csv.allRows.y.values[i],\n          ])\n        }\n\n        // Add centroids to the mapData\n        finalData.mapData[index].centroid[lastCentroidIndex] = wgs84[0]\n        finalData.mapData[index].centroid[lastCentroidIndex + 1] = wgs84[1]\n\n        // Update the number of values for time array in the mapData\n        finalData.mapData[index].numberOfFilledValues = lastValueIndex + 1\n        finalData.mapData[index].numberOfFilledCentroids = lastCentroidIndex + 2\n        finalData.mapData[index].numberOfFilledColors = lastColorIndex + 3\n      }\n\n      // Clean data (delete numberOfFilledXXXX)\n      Array.from(this.allTimes.keys()).forEach((index: number) => {\n        delete finalData.mapData[index].numberOfFilledValues\n        delete finalData.mapData[index].numberOfFilledCentroids\n        delete finalData.mapData[index].numberOfFilledColors\n      })\n\n      this.myState.statusMessage = ''\n      return finalData\n    },\n\n    resolveProjection() {\n      if (this.vizDetails.projection === 'EPSG:4326') return\n\n      for (let i = 0; i < this.data.length; i++) {\n        const wgs84 = Coords.toLngLat(this.vizDetails.projection, this.data[i].centroid)\n        this.data[i].centroid = wgs84\n      }\n    },\n\n    handleTimeSliderValues(timeValues: any[]) {\n      this.currentTime = timeValues\n      this.selectedTimeData = []\n\n      for (let i = 0; i < this.data.length; i++) {\n        if (this.data[i].time == timeValues[0]) {\n          this.selectedTimeData.push(this.data[i])\n        }\n      }\n    },\n\n    setupGui() {\n      this.guiController = new GUI({\n        title: 'Settings',\n        injectStyles: true,\n        width: 200,\n        container: document.getElementById(this.configId) || undefined,\n      })\n\n      const config = this.guiController // .addFolder('Colors')\n      config.add(this.guiConfig, 'radius', this.minRadius, this.maxRadius, this.radiusStep)\n      config.add(this.guiConfig, 'opacity', 0, 1, 0.1)\n      config.add(this.guiConfig, 'height', 0, 250, 5)\n\n      const colors = config.addFolder('colors')\n      colors.add(this.guiConfig, 'color ramp', this.guiConfig.colorRamps).onChange(this.setColors)\n      colors.add(this.guiConfig, 'flip').onChange(this.setColors)\n      // colors.add(this.guiConfig, 'steps').onChange(this.setColors)\n    },\n\n    setColors() {\n      const ramp = {\n        ramp: this.guiConfig['color ramp'],\n        // style: Style.sequential,\n      } as Ramp\n\n      console.log('Ramp: ', this.guiConfig['color ramp'])\n      console.log('n: ', this.guiConfig.steps)\n      const color = colorRamp(ramp, this.guiConfig.steps)\n\n      if (color.length == 0) {\n        const errorMessage = `Invalid color ramp: ${this.guiConfig['color ramp']}`\n        this.$store.commit('setStatus', {\n          type: Status.ERROR,\n          msg: 'Error',\n          desc: errorMessage,\n        })\n      }\n\n      if (color.length) {\n        this.colors = []\n      }\n\n      this.colors = this.hexArrayToRgbArray(color)\n\n      // colors.push(colorRamp({ ramp: this.guiConfig['color ramp'] } as Ramp, this.guiConfig.steps))\n\n      // let colors = [\n      //   ...colorRamp({ ramp: this.guiConfig['color ramp'],  } as Ramp, this.guiConfig.steps || 10),\n      // ]\n\n      // this.colors = this.hexArrayToRgbArray(\n      //   colorRamp({ ramp: this.guiConfig['color ramp'] } as Ramp, this.guiConfig.steps)\n      // )\n\n      if (this.guiConfig.flip) this.colors = this.colors.reverse()\n\n      console.log(this.colors)\n\n      // Recalculating the color values for the colorRamp\n      for (let i = 0; i < this.data.mapData.length; i++) {\n        for (let j = 0; j < this.data.mapData[i].values.length; j++) {\n          const value = this.data.mapData[i].values[j]\n          const colors = this.pickColor(value)\n          if (colors == undefined) break\n          for (let colorIndex = j * 3; colorIndex <= j * 3 + 2; colorIndex++) {\n            this.data.mapData[i].colorData[colorIndex] = colors[colorIndex % 3]\n          }\n        }\n      }\n\n      // force Vue to take notice of the change - any prop change will do\n      this.currentTime = [...this.currentTime]\n    },\n\n    hexArrayToRgbArray(hexArray: string[]): any {\n      const rgbArray = []\n\n      for (let i = 0; i < hexArray.length; i++) {\n        const hex = hexArray[i].replace(/^#/, '')\n        const r = parseInt(hex.substring(0, 2), 16)\n        const g = parseInt(hex.substring(2, 4), 16)\n        const b = parseInt(hex.substring(4, 6), 16)\n        rgbArray.push([r, g, b, 255])\n      }\n\n      return rgbArray\n    },\n\n    setCustomGuiConfig() {\n      if (!this.config) return\n\n      if (this.config.colorRamp) {\n        if (this.config.colorRamp.ramp != undefined)\n          this.guiConfig['color ramp'] = this.config.colorRamp.ramp\n\n        if (this.config.colorRamp.reverse != undefined)\n          this.guiConfig.flip = this.config.colorRamp.reverse\n\n        if (this.config.colorRamp.steps != undefined)\n          this.guiConfig.steps = this.config.colorRamp.steps\n      }\n\n      // Set custom radius\n      if (this.config.cellSize >= this.minRadius && this.config.cellSize <= this.maxRadius) {\n        this.guiConfig.radius = this.config.cellSize\n      }\n\n      // Set custom maxHeight\n      if (this.config.maxHeight) this.guiConfig.height = this.config.maxHeight\n\n      // Set custom opacity\n      if (this.config.opacity) this.guiConfig.opacity = this.config.opacity\n    },\n  },\n\n  async mounted() {\n    this.$store.commit('setFullScreen', !this.thumbnail)\n\n    this.myState.thumbnail = this.thumbnail\n    this.myState.yamlConfig = this.yamlConfig || ''\n    this.myState.subfolder = this.subfolder\n\n    await this.getVizDetails()\n\n    if (this.thumbnail) return\n\n    this.setupGui()\n\n    this.myState.statusMessage = `${this.$i18n.t('loading')}`\n\n    try {\n      this.data = await this.loadAndPrepareData()\n    } catch (e) {\n      this.$emit('error', 'Error loading ' + this.vizDetails.file)\n    }\n\n    this.setColors()\n    this.buildThumbnail()\n    this.isLoaded = true\n    this.setMapCenter()\n  },\n\n  beforeDestroy() {\n    // MUST erase the React view handle to prevent gigantic memory leak!\n    REACT_VIEW_HANDLES[this.id] = undefined\n    delete REACT_VIEW_HANDLES[this.id]\n\n    this.$store.commit('setFullScreen', false)\n  },\n})\n\nexport default GridMap\n</script>\n\n<style scoped lang=\"scss\">\n@import '@/styles.scss';\n\n.xy-hexagons {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  min-height: $thumbnailHeight;\n  background: url('assets/thumbnail.jpg') center / cover no-repeat;\n  z-index: -1;\n}\n\n.xy-hexagons.hide-thumbnail {\n  background: none;\n  z-index: 0;\n}\n\n.message {\n  z-index: 5;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  box-shadow: 0px 2px 10px #22222222;\n  display: flex;\n  flex-direction: row;\n  margin: auto auto 0 0;\n  background-color: var(--bgPanel);\n  padding: 0.5rem 1.5rem;\n\n  a {\n    color: white;\n    text-decoration: none;\n\n    &.router-link-exact-active {\n      color: white;\n    }\n  }\n\n  p {\n    font-size: 1.2rem;\n    line-height: 1.5rem;\n    font-weight: normal;\n    color: var(--textFancy);\n  }\n}\n\n.ui-slider {\n  padding: 0 0;\n  margin: 0.2rem 0 0.6rem 0;\n  min-width: 7rem;\n}\n\n.status-message {\n  font-size: 1.5rem;\n  line-height: 1.75rem;\n  font-weight: bold;\n}\n\n.big {\n  padding: 0.5rem 0;\n  font-size: 1.5rem;\n  line-height: 1.7rem;\n  font-weight: bold;\n}\n\n.top-right {\n  background-color: var(--bgPanel2);\n  color: white;\n  position: absolute;\n  top: 0;\n  right: 0;\n  z-index: 5;\n  border-left: 1px solid #66669940;\n  border-bottom: 1px solid #66669940;\n  box-shadow: 0px 0px 5px 3px rgba(128, 128, 128, 0.1);\n}\n\n.left-side {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column;\n  font-size: 0.8rem;\n  pointer-events: auto;\n  margin: 0 0 0 0;\n}\n\n.control-panel {\n  position: absolute;\n  bottom: 0;\n  display: flex;\n  flex-direction: row;\n  font-size: 0.8rem;\n  margin: 0 0 0.5rem 0.5rem;\n  pointer-events: auto;\n  background-color: var(--bgPanel);\n  padding: 0.5rem 0.5rem;\n  filter: drop-shadow(0px 2px 4px #22222233);\n}\n\n.is-dashboard {\n  position: static;\n  margin: 0 0;\n  padding: 0.25rem 0 0 0;\n  filter: unset;\n  background-color: unset;\n}\n\n.hex-layer {\n  pointer-events: auto;\n}\n\n.ui-label {\n  font-size: 0.8rem;\n  font-weight: bold;\n}\n\n.tooltip {\n  padding: 5rem 5rem;\n  background-color: #ccc;\n}\n\n.panel-items {\n  margin: 0.5rem 0.5rem;\n}\n\n.panel-item {\n  display: flex;\n  flex-direction: column;\n  margin-right: 1rem;\n  margin-left: 0.25rem;\n}\n\n.right {\n  margin-left: auto;\n}\n\ninput {\n  border: none;\n  background-color: #235;\n  color: #ccc;\n}\n\n.row {\n  display: 'grid';\n  grid-template-columns: 'auto 1fr';\n}\n\n.drawing-tool {\n  position: absolute;\n  top: 0;\n  right: 0;\n  pointer-events: none;\n}\n\n.time-slider-area {\n  position: absolute;\n  bottom: 0.5rem;\n  left: 0;\n  right: 0;\n  margin: 0 9rem 0 1rem;\n  filter: $filterShadow;\n}\n\n@media only screen and (max-width: 640px) {\n  .message {\n    padding: 0.5rem 0.5rem;\n  }\n\n  .right-side {\n    font-size: 0.7rem;\n  }\n\n  .big {\n    padding: 0 0rem;\n    margin-top: 0.5rem;\n    font-size: 1.3rem;\n    line-height: 2rem;\n  }\n}\n</style>\n"],"names":["CUBE_INDICES","CUBE_POSITIONS","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","CubeGeometry","Geometry","props","id","uid","defaultProps","GridCellLayer","ColumnLayer","diskResolution","uniforms","elevationScale","extruded","offset","coverage","cellSize","angle","radiusUnits","UNIT","_defineProperty","GRAB_HANDLE_WIDTH","_sfc_main","defineComponent","usableWidth","marginLeft","marginRight","parameter","left","right","result","mid","animationClockTime","sliderElement","index","h","m","hms","_a","durationWidth","deltaX","currentExtent","newLeft","newRight","newStartTime","newEndTime","Layer","viewId","colorRamp","dark","data","currentTimeIndex","mapIsIndependent","maxHeight","opacity","upperPercentile","viewState","setViewState","useState","globalStore","REACT_VIEW_HANDLES","view","handleViewState","colors","colormap","c","layers","React","DeckGL","e","StaticMap","MAPBOX_TOKEN","i18n","GridMap","CollapsiblePanel","DrawingTool","GridLayer","ToggleButton","ZoomButtons","TimeSlider","colorRamps","HTTPFileSystem","svnProject","a","lightmode","darkmode","ColorScheme","value","text","YAML","projection","Vue","filename","errorMessage","Status","hasYaml","configuration","t","buffer","base64","util","config","csv","minValue","maxValue","i","n1","n2","numberOfElementsPerTime","scaleFactor","finalData","time","msg","lastValueIndex","lastColorIndex","lastCentroidIndex","j","wgs84","Coords","timeValues","GUI","ramp","color","colorIndex","hexArray","rgbArray","hex","r","g","b"],"mappings":"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","x_google_ignoreList":[0,1]}