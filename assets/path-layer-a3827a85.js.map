{"version":3,"file":"path-layer-a3827a85.js","sources":["../../node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","../../node_modules/@math.gl/polygon/dist/esm/utils.js","../../node_modules/@math.gl/polygon/dist/esm/lineclip.js","../../node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","../../node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/webgl';\nexport default class Tesselator {\n  constructor(opts) {\n    _defineProperty(this, \"opts\", void 0);\n\n    _defineProperty(this, \"typedArrayManager\", void 0);\n\n    _defineProperty(this, \"indexStarts\", [0]);\n\n    _defineProperty(this, \"vertexStarts\", [0]);\n\n    _defineProperty(this, \"vertexCount\", 0);\n\n    _defineProperty(this, \"instanceCount\", 0);\n\n    _defineProperty(this, \"attributes\", void 0);\n\n    _defineProperty(this, \"_attributeDefs\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"getGeometry\", void 0);\n\n    _defineProperty(this, \"geometryBuffer\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"positionSize\", void 0);\n\n    _defineProperty(this, \"normalize\", void 0);\n\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({\n    startRow,\n    endRow\n  }) {\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n\n    if (!ArrayBuffer.isView(value)) {\n      return null;\n    }\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  _rebuildGeometry(dataRange) {\n    if (!this.data) {\n      return;\n    }\n\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = normalizedGeometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n      }, startRow, endRow);\n\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n\n    this._forEachGeometry((geometry, dataIndex) => {\n      const normalizedGeometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(normalizedGeometry, context);\n    }, startRow, endRow);\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n\n}\n//# sourceMappingURL=tesselator.js.map","export function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}\n//# sourceMappingURL=utils.js.map","import { push, copy, getPointAtIndex } from './utils';\nexport function clipPolyline(positions, bbox, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result = [];\n  let part = [];\n  let a;\n  let b;\n  let codeA = -1;\n  let codeB;\n  let lastCode;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nexport function clipPolygon(positions, bbox, options) {\n  const {\n    size = 2,\n    endIndex = positions.length\n  } = options || {};\n  let {\n    startIndex = 0\n  } = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result;\n  let p;\n  let prev;\n  let inside;\n  let prevInside;\n\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nexport function intersect(a, b, edge, bbox, out = []) {\n  let t;\n  let snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n\n  return out;\n}\nexport function bitCode(p, bbox) {\n  let code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n//# sourceMappingURL=lineclip.js.map","import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions, options) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nexport function cutPolygonByGrid(positions, holeIndices = null, options) {\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options || {};\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n//# sourceMappingURL=cut-by-grid.js.map","import { cutPolylineByGrid, cutPolygonByGrid } from './cut-by-grid';\nimport { getPointAtIndex, push } from './utils';\nconst DEFAULT_MAX_LATITUDE = 85.051129;\nexport function cutPolylineByMercatorBounds(positions, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length,\n    normalize = true\n  } = options || {};\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n\n  return parts;\n}\nexport function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {\n  const {\n    size = 2,\n    normalize = true,\n    edgeTypes = false\n  } = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions = [];\n  const newHoleIndices = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    const targetStartIndex = targetIndex;\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  let maxLat = -1;\n  let pointIndex = -1;\n\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  let prevLng = positions[0];\n  let lng;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  let refLng;\n  const pointCount = positions.length / size;\n\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map","import { cutPolylineByGrid, cutPolylineByMercatorBounds } from '@math.gl/polygon';\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath;\n\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path;\n  }\n\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {\n      size,\n      gridResolution\n    });\n  }\n\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {\n      size\n    });\n  }\n\n  return flatPath;\n}\n//# sourceMappingURL=path.js.map","import { Tesselator } from '@deck.gl/core';\nimport { normalizePath } from './path';\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\nexport default class PathTesselator extends Tesselator {\n  constructor(opts) {\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n\n    return path;\n  }\n\n  getGeometrySize(path) {\n    if (isCut(path)) {\n      let size = 0;\n\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n\n      return size;\n    }\n\n    const numPoints = this.getPathLength(path);\n\n    if (numPoints < 2) {\n      return 0;\n    }\n\n    if (this.isClosed(path)) {\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n\n    return numPoints;\n  }\n\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n\n    if (path && isCut(path)) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n\n      this._updatePositions(path, context);\n    }\n  }\n\n  _updateSegmentTypes(path, context) {\n    const segmentTypes = this.attributes.segmentTypes;\n    const isPathClosed = path ? this.isClosed(path) : false;\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  _updatePositions(path, context) {\n    const {\n      positions\n    } = this.attributes;\n\n    if (!positions || !path) {\n      return;\n    }\n\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    const p = new Array(3);\n\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n\n  getPointOnPath(path, index, target = []) {\n    const {\n      positionSize\n    } = this;\n\n    if (index * positionSize >= path.length) {\n      index += 1 - path.length / positionSize;\n    }\n\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = positionSize === 3 && path[i + 2] || 0;\n    return target;\n  }\n\n  isClosed(path) {\n    if (!this.normalize) {\n      return Boolean(this.opts.loop);\n    }\n\n    const {\n      positionSize\n    } = this;\n    const lastPointIndex = path.length - positionSize;\n    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);\n  }\n\n}\n\nfunction isCut(path) {\n  return Array.isArray(path[0]);\n}\n//# sourceMappingURL=path-tesselator.js.map","export default \"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute float instanceTypes;\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec3 instanceLeftPositions64Low;\\nattribute vec3 instanceStartPositions64Low;\\nattribute vec3 instanceEndPositions64Low;\\nattribute vec3 instanceRightPositions64Low;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float capType;\\nuniform float miterLimit;\\nuniform bool billboard;\\nuniform int widthUnits;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\n\\n// calculate line join positions\\nvec3 lineJoin(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  vec2 width\\n) {\\n  bool isEnd = positions.x > 0.0;\\n  // side of the segment - -1: left, 0: center, 1: right\\n  float sideOfPath = positions.y;\\n  float isJoint = float(sideOfPath == 0.0);\\n\\n  vec3 deltaA3 = (currPoint - prevPoint);\\n  vec3 deltaB3 = (nextPoint - currPoint);\\n\\n  mat3 rotationMatrix;\\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\\n  if (needsRotation) {\\n    deltaA3 = deltaA3 * rotationMatrix;\\n    deltaB3 = deltaB3 * rotationMatrix;\\n  }\\n  vec2 deltaA = deltaA3.xy / width;\\n  vec2 deltaB = deltaB3.xy / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n\\n  // tangent of the corner\\n  vec2 tangent = dirA + dirB;\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  // direction of the corner\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  // direction of the segment\\n  vec2 dir = isEnd ? dirA : dirB;\\n  // direction of the extrusion\\n  vec2 perp = isEnd ? perpA : perpB;\\n  // length of the segment\\n  float L = isEnd ? lenA : lenB;\\n\\n  // A = angle of the corner\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n\\n  // -1: right, 1: left\\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\\n\\n  // relative position to the corner:\\n  // -1: inside (smaller side of the angle)\\n  // 0: center\\n  // 1: outside (bigger side of the angle)\\n  float cornerPosition = sideOfPath * turnDirection;\\n\\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\\n  // trim if inside corner extends further than the line segment\\n  miterSize = mix(\\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\\n    miterSize,\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\\n    * (sideOfPath + isJoint * turnDirection);\\n\\n  // special treatment for start cap and end cap\\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\\n  bool isCap = isStartCap || isEndCap;\\n\\n  // extend out a triangle to envelope the round cap\\n  if (isCap) {\\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\\n    vJointType = capType;\\n  } else {\\n    vJointType = jointType;\\n  }\\n\\n  // Generate variables for fragment shader\\n  vPathLength = L;\\n  vCornerOffset = offsetVec;\\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\\n  vMiterLength = isCap ? isJoint : vMiterLength;\\n\\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\\n  vPathPosition = vec2(\\n    dot(offsetFromStartOfPath, perp),\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n  geometry.uv = vPathPosition;\\n\\n  float isValid = step(instanceTypes, 3.5);\\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\\n\\n  if (needsRotation) {\\n    offset = rotationMatrix * offset;\\n  }\\n  return currPoint + offset;\\n}\\n\\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\\n\\n  geometry.worldPosition = currPosition;\\n  vec2 widthPixels = vec2(clamp(\\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n  vec3 width;\\n\\n  if (billboard) {\\n    // Extrude in clipspace\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    width = vec3(widthPixels, 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec3 pos = lineJoin(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w,\\n      project_pixel_size_to_clipspace(width.xy)\\n    );\\n\\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    // Extrude in commonspace\\n    prevPosition = project_position(prevPosition, prevPosition64Low);\\n    currPosition = project_position(currPosition, currPosition64Low);\\n    nextPosition = project_position(nextPosition, nextPosition64Low);\\n\\n    width = vec3(project_pixel_size(widthPixels), 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec4 pos = vec4(\\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\\n      1.0);\\n    geometry.position = pos;\\n    gl_Position = project_common_position_to_clipspace(pos);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-vertex.glsl.js.map","export default \"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float miterLimit;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\n/*\\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\\n * vPathPosition.y - position along the length of the path, between [0, L / width].\\n */\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nvoid main(void) {\\n  geometry.uv = vPathPosition;\\n\\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\\n    // if joint is rounded, test distance from the corner\\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\\n      discard;\\n    }\\n    // trim miter\\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\\n      discard;\\n    }\\n  }\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-fragment.glsl.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  jointRounded: false,\n  capRounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  billboard: false,\n  _pathType: null,\n  getPath: {\n    type: 'accessor',\n    value: object => object.path\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  rounded: {\n    deprecatedFor: ['jointRounded', 'capRounded']\n  }\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nexport default class PathLayer extends Layer {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      positions: {\n        size: 3,\n        vertexOffset: 1,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: 5121,\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: 5121,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n    if (geometryChanged) {\n      const {\n        pathTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      info.object = data.find(d => d.__source.index === index);\n    }\n\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      jointType: Number(jointRounded),\n      capType: Number(capRounded),\n      billboard,\n      widthUnits: UNIT[widthUnits],\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];\n    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 4,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: {\n            value: new Float32Array(SEGMENT_POSITIONS),\n            size: 2\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculatePositions(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  calculateSegmentTypes(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n\n}\n\n_defineProperty(PathLayer, \"defaultProps\", defaultProps);\n\n_defineProperty(PathLayer, \"layerName\", 'PathLayer');\n//# sourceMappingURL=path-layer.js.map"],"names":["Tesselator","opts","_defineProperty","attributes","defaultTypedArrayManager","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","assert","dataRange","startRow","endRow","value","getAccessorFromBuffer","instanceCount","copy","_attributeDefs","typedArrayManager","name","def","visitor","iterable","objectInfo","createIterable","object","geometry","indexStarts","vertexStarts","normalizedData","dataIndex","normalizedGeometry","Buffer","byteStride","bufferValue","elementStride","context","vertexEnd","push","target","source","size","startIndex","isDuplicate","i","getPointAtIndex","positions","index","offset","out","startI","intersect","a","b","edge","bbox","t","snap","bitCode","p","code","cutPolylineByGrid","options","broken","gridResolution","gridOffset","endIndex","numPoints","part","result","codeB","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","holes","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","side","type","prev","prevSide","prevType","lowPointCount","highPointCount","left","bottom","minX","maxX","minY","maxY","x","y","DEFAULT_MAX_LATITUDE","cutPolylineByMercatorBounds","newPositions","wrapLongitudesForShortestPath","shiftLongitudesIntoRange","cutPolygonByMercatorBounds","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","findSplitIndex","insertPoleVertices","maxLat","pointIndex","lat","maxLatitude","firstLng","lastLng","prevLng","lng","delta","refLng","pointCount","normalizePath","path","wrapLongitude","flatPath","length","j","START_CAP","END_CAP","INVALID","PathTesselator","attributeName","buffer","isCut","subPath","geometrySize","segmentTypes","isPathClosed","vertexStart","ptIndex","positionSize","lastPointIndex","vs","fs","DEFAULT_COLOR","defaultProps","ATTRIBUTE_TRANSITION","chunk","PathLayer","Layer","args","project32","picking","params","props","changeFlags","attributeManager","pathTesselator","_this$state$model","gl","info","d","objectIndex","uniforms","jointRounded","capRounded","billboard","miterLimit","widthUnits","widthScale","widthMinPixels","widthMaxPixels","UNIT","SEGMENT_INDICES","SEGMENT_POSITIONS","Model","Geometry","attribute"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}