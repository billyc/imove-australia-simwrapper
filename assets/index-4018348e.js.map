{"version":3,"file":"index-4018348e.js","sources":["../../node_modules/crossfilter2/src/array.js","../../node_modules/crossfilter2/src/filter.js","../../node_modules/crossfilter2/src/identity.js","../../node_modules/crossfilter2/src/null.js","../../node_modules/crossfilter2/src/zero.js","../../node_modules/crossfilter2/src/heap.js","../../node_modules/crossfilter2/src/heapselect.js","../../node_modules/crossfilter2/src/bisect.js","../../node_modules/crossfilter2/src/permute.js","../../node_modules/crossfilter2/src/reduce.js","../../node_modules/@ranfdev/deepobj/dist/deepobj.m.js","../../node_modules/crossfilter2/src/result.js","../../node_modules/crossfilter2/src/index.js"],"sourcesContent":["let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask = (mask & zero) >>> 0;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n","const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n","export default d => {\n  return d;\n};\n","export default () =>  {\n  return null;\n}\n","export default () => {\n  return 0;\n}\n","import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n","import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n","import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n","export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n","const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n","export default function(t,e,i,n,r){for(r in n=(i=i.split(\".\")).splice(-1,1),i)e=e[i[r]]=e[i[r]]||{};return t(e,n)};\n//# sourceMappingURL=deepobj.m.js.map\n","import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n","import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n\n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n\n    function currentFilter() {\n      return filterValue;\n    }\n\n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n            groupIndex = groupIndex.slice(0, j);\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n"],"names":["array8","arrayUntyped","array16","array32","arrayLengthen","arrayLengthenUntyped","arrayWiden","arrayWidenUntyped","n","array","length","copy","width","i","bitarray","len","m","w","one","dest","src","j","offset","zero","mask","onlyOffset","onlyOne","xfilterArray","filterExact","bisect","value","values","filterRange","range","min","max","filterAll","xfilterFilter","cr_identity","d","cr_null","cr_zero","heap_by","heap","a","lo","hi","sift","sort","t","x","child","h","identity","heapselect_by","xFilterHeap","heapselect","k","queue","bisect_by","bisectLeft","mid","bisectRight","permute","index","deep","reduceIncrement","p","reduceDecrement","reduceAdd","v","reduceSubtract","xfilterReduce","e","r","get","obj","prop","reg","result","path","REMOVED_INDEX","crossfilter","xfilterHeap","xfilterHeapselect","add","removeData","dimension","groupAll","size","all","allFiltered","onChange","isElementFiltered","data","filters","filterListeners","dataListeners","removeDataListeners","callbacks","newData","n0","n1","l","triggerOnChange","predicate","newIndex","removed","usePred","shouldRemove","index1","index2","index3","index4","maskForDimensions","dimensions","id","ignore_dimensions","iterable","accessorPath","filter","filterFunction","currentFilter","hasCurrentFilter","top","bottom","group","dispose","newValues","iterablesIndexCount","iterablesIndexFilterStatus","iterablesEmptyRows","sortRange","cr_range","A","B","b","refilter","refilterFunction","filterValue","filterValuePresent","indexListeners","dimensionGroups","lo0","hi0","preAdd","postAdd","tmp","newIterablesIndexCount","newIterablesIndexFilterStatus","i0","cr_index","unsortedIndex","sortMap","bounds","lo1","hi1","oldValues","oldIndex","oldIterablesIndexFilterStatus","old_n0","i1","oldiiclength","index5","reIndex","oldDataIndex","filterIndexBounds","filterIndexFunction","added","valueIndexAdded","valueIndexRemoved","newAdded","newRemoved","f","indexLength","top_offset","toSkip","bottom_offset","key","reduce","reduceCount","reduceSum","order","orderNatural","groups","groupIndex","groupWidth","groupCapacity","capacity","select","reduceRemove","reduceInitial","update","reset","resetNeeded","n0old","oldGroups","remove","initial","k0","g0","x0","x1","g","groupIncrement","updateMany","resetMany","updateOne","resetOne","oldK","seenGroups","filterOne","filterOffset","notFilter","valueOf","reduceValue","cb","eventName"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}