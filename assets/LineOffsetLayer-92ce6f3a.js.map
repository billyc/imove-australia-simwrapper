{"version":3,"file":"LineOffsetLayer-92ce6f3a.js","sources":["../../src/layers/line-offset-shader-full.vert?raw","../../src/layers/LineOffsetLayer.ts"],"sourcesContent":["export default \"#define SHADER_NAME line-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 instanceSourcePositions;\\nattribute vec3 instanceTargetPositions;\\nattribute vec3 instanceSourcePositions64Low;\\nattribute vec3 instanceTargetPositions64Low;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute float instanceWidths;\\n\\nuniform float opacity;\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float useShortestPath;\\nuniform int widthUnits;\\n\\nuniform float offsetDirection;\\nuniform float bearing;\\n\\nvarying vec4 vColor;\\nvarying vec2 uv;\\n\\n// offset vector by strokeWidth pixels\\n// offset_direction is -1 (left) or 1 (right)\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n\\n  return dir_screenspace * offset_direction * width / 2.0;\\n}\\n\\nvec3 splitLine(vec3 a, vec3 b, float x) {\\n  float t = (x - a.x) / (b.x - a.x);\\n  return vec3(x, mix(a.yz, b.yz, t));\\n}\\n\\nvoid drivingSideOffset(inout vec3 size, float widthPixels) {\\n\\n    // a -> b\\n    vec3 link = geometry.worldPositionAlt.xyz - geometry.worldPosition.xyz;\\n\\n    // normalized direction of the line\\n    vec2 direction = normalize(link.xy * project_uViewportSize);\\n\\n    // rotate by map bearing\\n    vec2 rotation;\\n    rotation.x = direction.x * cos(bearing) + direction.y * -sin(bearing);\\n    rotation.y = direction.x * sin(bearing) + direction.y *  cos(bearing);\\n\\n    // rotate by 90 degrees to get offset direction\\n    rotation = vec2(-rotation.y, rotation.x);\\n\\n    // offset the coordinates\\n    vec2 offset = rotation * offsetDirection * widthPixels / 2.0;\\n\\n    size.x += offset.x;\\n    size.y += offset.y;\\n}\\n\\nvoid main(void) {\\n  geometry.worldPosition = instanceSourcePositions;\\n  geometry.worldPositionAlt = instanceTargetPositions;\\n\\n  vec3 source_world = instanceSourcePositions;\\n  vec3 target_world = instanceTargetPositions;\\n  vec3 source_world_64low = instanceSourcePositions64Low;\\n  vec3 target_world_64low = instanceTargetPositions64Low;\\n\\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\\n    float deltaLng = target_world.x - source_world.x;\\n\\n    if (deltaLng * useShortestPath > 180.) {\\n      source_world.x += 360. * useShortestPath;\\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\\n      source_world_64low = vec3(0.0);\\n    } else if (deltaLng * useShortestPath < -180.) {\\n      target_world.x += 360. * useShortestPath;\\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\\n      target_world_64low = vec3(0.0);\\n    } else if (useShortestPath < 0.) {\\n      // Line is not split, abort\\n      gl_Position = vec4(0.);\\n      return;\\n    }\\n  }\\n\\n  // Position\\n  vec4 source_commonspace;\\n  vec4 target_commonspace;\\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\\n\\n  // linear interpolation of source & target to pick right coord\\n  float segmentIndex = positions.x;\\n  vec4 p = mix(source, target, segmentIndex);\\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\\n  uv = positions.xy;\\n  geometry.uv = uv;\\n  geometry.pickingColor = instancePickingColors;\\n\\n  // Multiply out width and clamp to limits\\n  float widthPixels = clamp(\\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\\n    widthMinPixels, widthMaxPixels\\n  );\\n\\n  // extrude\\n  vec3 offset = vec3(\\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\\n    0.0);\\n\\n  drivingSideOffset(offset, 1.0 + widthPixels);\\n\\n  DECKGL_FILTER_SIZE(offset, geometry);\\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  // Color\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\"","import { LineLayer } from '@deck.gl/layers'\n\nimport globalStore from '@/store'\nimport SHADER_VERTEX_FULL from './line-offset-shader-full.vert?raw'\n\nexport const OFFSET_DIRECTION = {\n  NONE: 0,\n  LEFT: 1,\n  RIGHT: -1,\n}\n\nexport class LineOffsetLayer extends LineLayer {\n  initializeState(context: any) {\n    super.initializeState(context)\n  }\n\n  getShaders() {\n    return {\n      ...super.getShaders(),\n      vs: SHADER_VERTEX_FULL,\n    }\n  }\n\n  draw({ uniforms }: any) {\n    const { offsetDirection } = this.props\n\n    const combinedUniforms = {\n      ...uniforms,\n      offsetDirection,\n      bearing: (globalStore.state.viewState.bearing * Math.PI) / 180.0,\n    }\n\n    super.draw({\n      uniforms: combinedUniforms,\n    })\n  }\n}\n\nLineOffsetLayer.layerName = 'LineOffsetLayer'\nLineOffsetLayer.defaultProps = {\n  bearing: 0,\n  offsetDirection: OFFSET_DIRECTION.RIGHT,\n}\n"],"names":["SHADER_VERTEX_FULL","OFFSET_DIRECTION","LineOffsetLayer","LineLayer","context","uniforms","offsetDirection","combinedUniforms","globalStore"],"mappings":"qFAAA,MAAeA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECKFC,EAAmB,CAC9B,KAAM,EACN,KAAM,EACN,MAAO,EACT,EAEO,MAAMC,UAAwBC,CAAU,CAC7C,gBAAgBC,EAAc,CAC5B,MAAM,gBAAgBA,CAAO,CAC/B,CAEA,YAAa,CACJ,MAAA,CACL,GAAG,MAAM,WAAW,EACpB,GAAIJ,CAAA,CAER,CAEA,KAAK,CAAE,SAAAK,GAAiB,CAChB,KAAA,CAAE,gBAAAC,CAAgB,EAAI,KAAK,MAE3BC,EAAmB,CACvB,GAAGF,EACH,gBAAAC,EACA,QAAUE,EAAY,MAAM,UAAU,QAAU,KAAK,GAAM,GAAA,EAG7D,MAAM,KAAK,CACT,SAAUD,CAAA,CACX,CACH,CACF,CAEAL,EAAgB,UAAY,kBAC5BA,EAAgB,aAAe,CAC7B,QAAS,EACT,gBAAiBD,EAAiB,KACpC"}