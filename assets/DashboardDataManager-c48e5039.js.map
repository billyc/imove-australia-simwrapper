{"version":3,"file":"DashboardDataManager-c48e5039.js","sources":["../../src/js/DashboardDataManager.ts"],"sourcesContent":["/**\n * DashboardDataManager: this class loads, caches, and filters CSV and XML datasets\n * for use by dashboard charts and maps. Loosely based on the VizWit system\n * (see http://vizwit.io/) but we don't have a Carto database so all of the data\n * is stored internally in this class.\n *\n * Each tabbed dashboard should instantiate this class once, and destroy it when the dashboard\n * is closed. Datasets can be big, we don't want them to stick around forever!\n *\n * Data queries always return -both- the full dataset AND a filtered dataset.\n * That way, the filtered data can be visually layered on top of the full data.\n */\n\nimport { rollup } from 'd3-array'\n\nimport globalStore from '@/store'\nimport HTTPFileSystem from './HTTPFileSystem'\nimport { DataTable, DataTableColumn, DataType, FileSystemConfig, Status } from '@/Globals'\nimport { findMatchingGlobInFiles } from '@/js/util'\n\nimport DataFetcherWorker from '@/workers/DataFetcher.worker.ts?worker'\nimport RoadNetworkLoader from '@/workers/RoadNetworkLoader.worker.ts?worker'\n\ninterface configuration {\n  dataset: string\n  groupBy?: string\n  value?: string\n  usedCol?: string[]\n  columns?: string[]\n  ignoreColumns?: any[]\n  skipFirstRow?: boolean\n  useLastRow?: boolean\n  x?: string\n}\n\nexport interface FilterDefinition {\n  dataset: string\n  column: string\n  value: any\n  operator?: string\n  invert?: boolean\n  range?: boolean\n}\n\nexport interface NetworkLinks {\n  source: Float32Array\n  dest: Float32Array\n  linkIds: any[]\n  projection: String\n}\n\n// This tells us if our environment has the Chrome File System Access API, meaning we are in Chrome\n//@ts-ignore\nconst isChrome = !!window.showDirectoryPicker\nconst isFirefox = !isChrome\n\nexport default class DashboardDataManager {\n  constructor(...args: string[]) {\n    // hello\n    this.root = args.length ? args[0] : ''\n    this.subfolder = args.length ? args[1] : ''\n    this.fileApi = this._getFileSystem(this.root)\n  }\n\n  private files: any[] = []\n  private threads: Worker[] = []\n  private subfolder = ''\n  private root = ''\n  private fileApi: FileSystemConfig\n  private networks: { [id: string]: Promise<NetworkLinks> } = {}\n\n  public kill() {\n    for (const worker of this.threads) worker.terminate()\n  }\n\n  public getFilteredDataset(config: { dataset: string }): { filteredRows: any[] | null } {\n    if (!(config.dataset in this.datasets)) return { filteredRows: null }\n\n    const filteredRows = this.datasets[config.dataset].filteredRows\n    return { filteredRows }\n  }\n\n  public async OLDgetFiltered(config: { dataset: string; groupBy?: string; value?: string }) {\n    const rows = this.datasets[config.dataset].filteredRows\n    if (!rows) return { filteredRows: null }\n\n    // group the rows as needed\n    let bars: any = {}\n\n    if (config.value && config.groupBy) {\n      const columnValues = config.value\n      const columnGroups = config.groupBy\n      bars = rollup(\n        rows,\n        v => v.reduce((a, b) => a + b[columnValues], 0),\n        (d: any) => d[columnGroups] // group-by\n      )\n    } else {\n      // TODO need to handle non-value, non-group here\n    }\n    const x = Array.from(bars.keys())\n    const y = Array.from(bars.values())\n\n    // filter the rows, too\n\n    return { filteredRows: { x, y } }\n  }\n\n  /**\n   *\n   * @param config the configuration params from the YAML file. Must include dataset,\n   *               and may include other optional parameters as needed by the viz\n   * @returns allRows object, containing a DataTableColumn for each column in this dataset\n   */\n  public async getDataset(config: configuration, options?: { highPrecision: boolean }) {\n    try {\n      // first, get the dataset\n      if (!this.datasets[config.dataset]) {\n        console.log('load:', config.dataset)\n\n        // fetchDataset() immediately returns a Promise<>, which we await on\n        // so that multiple charts don't all try to fetch the dataset individually\n        this.datasets[config.dataset] = {\n          dataset: this._fetchDataset(config, options),\n          activeFilters: {},\n          filteredRows: null,\n          filterListeners: new Set(),\n        }\n      }\n\n      // wait for dataset to load\n      // (this will immediately return dataset if it is already loaded)\n      let myDataset = await this.datasets[config.dataset].dataset\n\n      // make a copy because each viz in a dashboard might be hacking it differently\n      // TODO: be more \"functional\" and return the object itself, and let views create copies if they need to\n      let allRows = { ...myDataset }\n\n      // remove ignored columns\n      if (config.ignoreColumns) {\n        config.ignoreColumns.forEach(column => {\n          delete allRows[column]\n        })\n      }\n\n      // if useLastRow, drop all rows except the last row\n      if (config.useLastRow) {\n        Object.keys(allRows).forEach(colName => {\n          const values = myDataset[colName].values\n          allRows[colName] = values[values.length - 1]\n        })\n      }\n\n      return { allRows }\n    } catch (e) {\n      // const message = '' + e\n      return { allRows: {} }\n    }\n  }\n\n  /**\n   * Convert features array from GeoJSONs and Shapefiles into DataTable\n   * @param filename\n   * @param featureProperties array of feature objects\n   */\n  public setFeatureProperties(fullpath: string, featureProperties: any[], config: any) {\n    const key = fullpath.substring(fullpath.lastIndexOf('/') + 1)\n\n    // merge key with keep/drop params (etc)\n    let fullConfig = { dataset: key }\n    if ('string' !== typeof config) fullConfig = Object.assign(fullConfig, config)\n\n    this.datasets[key] = {\n      activeFilters: {},\n      filteredRows: null,\n      filterListeners: new Set(),\n      dataset: new Promise<DataTable>((resolve, reject) => {\n        const thread = new DataFetcherWorker()\n        // console.log('NEW WORKER', thread)\n        this.threads.push(thread)\n\n        try {\n          thread.postMessage({ config: fullConfig, featureProperties })\n\n          thread.onmessage = e => {\n            thread.terminate()\n            if (e.data.error) {\n              console.error(e.data.error)\n              reject(`Problem loading properties in ${fullpath}`)\n            }\n            resolve(e.data)\n          }\n        } catch (err) {\n          thread.terminate()\n          console.error(err)\n          reject(err)\n        }\n      }),\n    }\n    // this is a promise:\n    return this.datasets[key].dataset\n  }\n\n  /**\n   *  Register an existing in-memory DataTable as a dataset in this Dashboard\n   * @param props key, dataTable, and filename associated with this DataTable\n   */\n  public setPreloadedDataset(props: { key: string; dataTable: DataTable }) {\n    // let filters = {}\n    // if (this.datasets[props.key]) {\n    //   filters = this.datasets[props.key].activeFilters\n    // }\n\n    this.datasets[props.key] = {\n      dataset: new Promise<DataTable>((resolve, reject) => {\n        resolve(props.dataTable)\n      }),\n      activeFilters: {}, // filters,\n      filteredRows: null,\n      filterListeners: new Set(),\n    }\n  }\n\n  public async getRoadNetwork(\n    filename: string,\n    subfolder: string,\n    vizDetails: any,\n    cbStatus?: any\n  ) {\n    const path = `/${subfolder}/${filename}`\n    // Get the dataset the first time it is requested\n    if (!this.networks[path]) {\n      this.networks[path] = this._fetchNetwork({ subfolder, filename, vizDetails, cbStatus })\n    }\n\n    // wait for the worker to provide the network\n    let network = await this.networks[path]\n    return network\n  }\n\n  // /**\n  //  * Load simple dataset without grouping/filtering\n  //  * @param allRows Each row\n  //  * @returns TBD\n  //  */\n  // public loadSimple(config: configuration, allRows: any[]) {\n  //   // Simple requires x and columns/usedCol\n  //   if (!config.x || (!config.columns && !config.usedCol)) {\n  //     throw Error('Config requires \"x\" and \"columns\" parameters')\n  //   }\n\n  //   var useOwnNames = false\n\n  //   const x = [] as any[]\n\n  //   for (var i = 0; i < allRows.length; i++) {\n  //     if (i == 0 && config.skipFirstRow) {\n  //     } else {\n  //       x.push(allRows[i][config.x])\n  //     }\n  //   }\n\n  //   const columns = config.columns || config.usedCol || []\n\n  //   for (let i = 0; i < columns.length; i++) {\n  //     const name = columns[i]\n  //     let legendName = ''\n  //     if (columns[i] !== 'undefined') {\n  //       if (useOwnNames) {\n  //         legendName = this.config.legendTitles[i]\n  //       } else {\n  //         legendName = name\n  //       }\n  //       const value = []\n  //       for (var j = 0; j < this.dataRows.length; j++) {\n  //         if (j == 0 && this.config.skipFirstRow) {\n  //         } else {\n  //           value.push(this.dataRows[j][name])\n  //         }\n  //       }\n  //       this.data.push({\n  //         x: x,\n  //         y: value,\n  //         name: legendName,\n  //         type: 'bar',\n  //         textinfo: 'label+percent',\n  //         textposition: 'inside',\n  //         automargin: true,\n  //       })\n  //     }\n  //   }\n  // }\n\n  public setFilter(filter: FilterDefinition) {\n    const { dataset, column, value, invert, range } = filter\n\n    if (!this.datasets[dataset]) {\n      console.warn(`${dataset} doesn't exist yet`)\n      console.warn(Object.keys(this.datasets))\n      return\n    }\n    console.log('> setFilter', dataset, column, value)\n\n    // Filter might be single or an array; make it an array.\n    const values = Array.isArray(value) ? value : [value]\n    if (this.datasets[dataset].activeFilters == null) {\n      this.datasets[dataset].activeFilters = {}\n    }\n    const allFilters = this.datasets[dataset].activeFilters\n    // a second click on a filter means REMOVE this filter.\n    // if (allFilters[column] !== undefined && allFilters[column] === values) {\n    //   console.log('A1', allFilters[column])\n    //   delete allFilters[column]\n    // } else\n    if (!values.length) {\n      delete allFilters[column]\n    } else {\n      allFilters[column] = { values, invert, range }\n    }\n    this._updateFilters(dataset) // this is async\n  }\n\n  public addFilterListener(config: { dataset: string }, listener: any) {\n    const selectedDataset = this.datasets[config.dataset]\n    if (!selectedDataset) throw Error('No dataset named: ' + config.dataset)\n\n    // console.log(22, config.dataset, this.datasets[config.dataset])\n    this.datasets[config.dataset].filterListeners.add(listener)\n  }\n\n  public removeFilterListener(config: { dataset: string }, listener: any) {\n    try {\n      if (this.datasets[config.dataset].filterListeners) {\n        this.datasets[config.dataset].filterListeners.delete(listener)\n      }\n    } catch (e) {\n      // doesn't matter\n    }\n  }\n\n  public clearCache() {\n    this.kill() // any stragglers must die\n    this.datasets = {}\n    this.networks = {}\n  }\n\n  // ---- PRIVATE STUFFS -----------------------\n\n  private async _updateFilters(datasetId: string) {\n    console.log('> updateFilters ', datasetId)\n    const metaData = this.datasets[datasetId]\n    console.log({ metaData })\n\n    if (!Object.keys(metaData.activeFilters).length) {\n      console.log('no keys')\n      metaData.filteredRows = null\n      this._notifyListeners(datasetId)\n      return\n    }\n\n    // Let's do this the stupid way first, and make it better once we get it working.\n    const dataset = await metaData.dataset\n    const allColumns = Object.keys(dataset)\n    let filteredRows: any[] = []\n\n    const numberOfRowsInFullDataset = dataset[allColumns[0]].values.length\n    console.log('FILTERS:', metaData.activeFilters)\n    console.log('TOTLROWS', numberOfRowsInFullDataset)\n\n    // we will go thru each filter for this dataset and set the elements\n    // to false whenever a row fails a filter.\n    // This implements \"AND\" logic.\n    const hasMatchedFilters = new Array(numberOfRowsInFullDataset).fill(true)\n\n    const ltgt = /^(<|>)/ // starts with < or >\n    //            (╯° °)╯︵ ┻━┻\n\n    for (const [column, spec] of Object.entries(metaData.activeFilters)) {\n      const dataColumn = dataset[column]\n      if (spec.values[0] === undefined || spec.values[0] === '') {\n        throw Error(datasetId + ': filter error')\n      }\n\n      // prep LT/GT\n      if (ltgt.test(spec.values[0])) {\n        if (spec.values[0].startsWith('<=')) {\n          spec.conditional = '<='\n          spec.values[0] = spec.values[0].substring(2).trim()\n        } else if (spec.values[0].startsWith('>=')) {\n          spec.conditional = '>='\n          spec.values[0] = spec.values[0].substring(2).trim()\n        } else if (spec.values[0].startsWith('<')) {\n          spec.conditional = '<'\n          spec.values[0] = spec.values[0].substring(1).trim()\n        } else if (spec.values[0].startsWith('>')) {\n          spec.conditional = '>'\n          spec.values[0] = spec.values[0].substring(1).trim()\n        }\n      } else {\n        // handle case where we are testing equal/inequal and its a \"numeric\" string\n        if (spec.values.length === 1 && typeof spec.values[0] === 'string') {\n          const numericString = parseFloat(spec.values[0])\n          if (Number.isFinite(numericString)) spec.values.push(numericString)\n        }\n      }\n\n      // test every row: falsify if it fails the test.\n      for (let i = 0; i < numberOfRowsInFullDataset; i++) {\n        if (!checkFilterValue(spec, dataColumn.values[i])) {\n          hasMatchedFilters[i] = false\n        }\n      }\n    }\n\n    // Build the final filtered dataset based on hasMatchedFilters\n    for (let i = 0; i < numberOfRowsInFullDataset; i++) {\n      if (hasMatchedFilters[i]) {\n        const row = {} as any\n        allColumns.forEach(col => (row[col] = dataset[col].values[i]))\n        filteredRows.push(row)\n      }\n    }\n\n    // For now let's leave the filtered rows as an array of data objects\n\n    // // CONVERT array of objects to column-based DataTableColumns\n    // const filteredDataTable: { [id: string]: DataTableColumn } = {}\n    // allColumns.forEach(columnId => {\n    //   const column = { name: columnId, values: [], type: DataType.UNKNOWN } as any\n    //   for (const row of filteredRows) column.values.push(row[columnId])\n    //   filteredDataTable[columnId] = column\n    // })\n\n    // metaData.filteredRows = filteredDataTable as any\n\n    metaData.filteredRows = filteredRows\n    this._notifyListeners(datasetId)\n  }\n\n  // private _checkFilterValue(\n  //   spec: { conditional: string; invert: boolean; values: any[] },\n  //   elementValue: any\n  // ) {\n  //   // lookup closure functions for < > <= >=\n  //   const conditionals: any = {\n  //     '<': () => {\n  //       return elementValue < spec.values[0]\n  //     },\n  //     '<=': () => {\n  //       return elementValue <= spec.values[0]\n  //     },\n  //     '>': () => {\n  //       return elementValue > spec.values[0]\n  //     },\n  //     '>=': () => {\n  //       return elementValue >= spec.values[0]\n  //     },\n  //   }\n\n  //   let isValueInFilterSpec: boolean\n\n  //   if (spec.conditional) {\n  //     isValueInFilterSpec = conditionals[spec.conditional]()\n  //   } else {\n  //     isValueInFilterSpec = spec.values.includes(elementValue)\n  //   }\n\n  //   if (spec.invert) return !isValueInFilterSpec\n  //   return isValueInFilterSpec\n  // }\n\n  private _notifyListeners(datasetId: string) {\n    const dataset = this.datasets[datasetId]\n    for (const notifyListener of dataset.filterListeners) {\n      notifyListener(datasetId)\n    }\n  }\n\n  private async _fetchDataset(config: { dataset: string }, options?: { highPrecision: boolean }) {\n    if (!this.files.length) {\n      const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(this.subfolder)\n      this.files = files\n    }\n\n    return new Promise<DataTable>((resolve, reject) => {\n      const thread = new DataFetcherWorker()\n      this.threads.push(thread)\n      // console.log('NEW WORKER', thread)\n      try {\n        thread.postMessage({\n          fileSystemConfig: this.fileApi,\n          subfolder: this.subfolder,\n          files: this.files,\n          config: config,\n          options,\n        })\n\n        thread.onmessage = e => {\n          thread.terminate()\n          if (e.data.error) {\n            let msg = '' + e.data.error\n            msg = msg.replace('[object Response]', 'Error loading file')\n\n            if (config?.dataset && msg.indexOf(config.dataset) === -1) msg += `: ${config.dataset}`\n\n            reject(msg)\n          }\n          resolve(e.data)\n        }\n      } catch (err) {\n        thread.terminate()\n        console.error(err)\n        reject(err)\n      }\n    })\n  }\n\n  private async _fetchNetwork(props: {\n    subfolder: string\n    filename: string\n    vizDetails: any\n    cbStatus?: any\n  }) {\n    return new Promise<NetworkLinks>(async (resolve, reject) => {\n      const { subfolder, filename, vizDetails, cbStatus } = props\n\n      const path = `/${subfolder}/${filename}`\n      console.log('load network:', path)\n\n      // get folder\n      let folder =\n        path.indexOf('/') > -1 ? path.substring(0, path.lastIndexOf('/')) : this.subfolder\n\n      // get file path search pattern\n      try {\n        const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(folder)\n        let pattern = path.indexOf('/') === -1 ? path : path.substring(path.lastIndexOf('/') + 1)\n        const match = findMatchingGlobInFiles(files, pattern)\n        if (match.length !== 1) reject('File not found: ' + path)\n      } catch (e) {\n        // Could not get directory listing!\n        reject('Error reading folder: ' + folder)\n      }\n\n      const thread = new RoadNetworkLoader() as any\n      try {\n        thread.onmessage = (e: MessageEvent) => {\n          // perhaps network has no CRS and we need to ask user\n          if (e.data.promptUserForCRS) {\n            let crs =\n              prompt(\n                'Enter the projection coordinate reference system, e.g. \"EPSG:25832\", or cancel if unknown'\n              ) || 'Atlantis'\n            if (Number.isInteger(parseInt(crs))) crs = `EPSG:${crs}`\n\n            thread.postMessage({ crs })\n            return\n          }\n\n          // notify client of status update messages\n          if (e.data.status) {\n            if (cbStatus) cbStatus(e.data.status)\n            return\n          }\n\n          // normal exit\n          thread.terminate()\n\n          if (e.data.error) {\n            console.error(e.data.error)\n            reject(e.data.error)\n          }\n\n          resolve(e.data.links)\n        }\n\n        thread.postMessage({\n          filePath: path,\n          fileSystem: this.fileApi,\n          vizDetails,\n          isFirefox, // we need this for now, because Firefox bug #260\n        })\n      } catch (err) {\n        thread.terminate()\n        console.error(err)\n        reject(err)\n      }\n    })\n  }\n\n  private _getFileSystem(name: string) {\n    const svnProject: FileSystemConfig[] = globalStore.state.svnProjects.filter(\n      (a: FileSystemConfig) => a.slug === name\n    )\n    if (svnProject.length === 0) {\n      // console.log(globalStore.state.svnProjects)\n      console.error(`DDM: no such project, is slug correct? (${name})`)\n      throw Error\n    }\n    return svnProject[0]\n  }\n\n  private datasets: {\n    [id: string]: {\n      dataset: Promise<DataTable>\n      filteredRows: any[] | null\n      activeFilters: { [column: string]: any }\n      filterListeners: Set<any>\n    }\n  } = {}\n}\n\nexport function checkFilterValue(\n  spec: { conditional: string; invert: boolean; values: any[]; range?: boolean },\n  elementValue: any\n) {\n  // lookup closure functions for < > <= >=\n  const conditionals: any = {\n    '<': () => {\n      return elementValue < spec.values[0]\n    },\n    '<=': () => {\n      return elementValue <= spec.values[0]\n    },\n    '>': () => {\n      return elementValue > spec.values[0]\n    },\n    '>=': () => {\n      return elementValue >= spec.values[0]\n    },\n  }\n\n  let isValueInFilterSpec: boolean\n\n  if (spec.range) {\n    isValueInFilterSpec = elementValue >= spec.values[0] && elementValue <= spec.values[1]\n  } else if (spec.conditional) {\n    isValueInFilterSpec = conditionals[spec.conditional]()\n  } else {\n    isValueInFilterSpec = spec.values.includes(elementValue)\n  }\n\n  if (spec.invert) return !isValueInFilterSpec\n  return isValueInFilterSpec\n}\n"],"names":["isChrome","isFirefox","DashboardDataManager","args","__publicField","worker","config","rows","bars","columnValues","columnGroups","rollup","v","a","b","d","x","y","options","myDataset","allRows","column","colName","values","fullpath","featureProperties","key","fullConfig","resolve","reject","thread","DataFetcherWorker","e","err","props","filename","subfolder","vizDetails","cbStatus","path","filter","dataset","value","invert","range","allFilters","listener","datasetId","metaData","allColumns","filteredRows","numberOfRowsInFullDataset","hasMatchedFilters","ltgt","spec","dataColumn","numericString","i","checkFilterValue","row","col","notifyListener","files","HTTPFileSystem","msg","folder","pattern","findMatchingGlobInFiles","RoadNetworkLoader","crs","name","svnProject","globalStore","elementValue","conditionals","isValueInFilterSpec"],"mappings":"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"}